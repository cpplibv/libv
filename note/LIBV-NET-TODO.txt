libv.diff: make sure every stream input respects offset (?) | for output it makes sense, but for input I need the end of it | Done with byte streams
libv.hash: Generate md5 hash from file without needing to handle the istream
libv.update: patch create folder
libv.update: patch remove folder
<<<<<<< HEAD
=======
libv.update: Patch apply progress report
libv.update: Patch improved logging
libv.state: Find a state machine solution | for now boost statechart will be good enough
libv.mt: pimpl worker_thread_pool and worker_thread
libv.mt: common base queue for worker_thread_pool and worker_thread only difference is "run" calls (?)
>>>>>>> 03b6533... libv.mt: Add common baseclass and pimpl for worker_thread and worker_thread_pool
















































--- STACK ------------------------------------------------------------------------------------------

pimpl worker_thread_pool and worker_thread
common base queue for worker_thread_pool and worker_thread only difference is "run" calls (?)

libv.mt: worker_thread_pool and worker_thread, solve the next index loop around problem


app/update/res/gen.sh
app/update/res/apply.sh

app/update/res/gen.sh && app/update/res/apply.sh

STACK
	> worker_thread_pool
	> async_value
	> ResourceServer Peer
	> ResourceServer Peer State machine
	> Connection
	> ConnectionSet
	> Codec
	> ResourceServer
	> ResourceClient
	> ResourceDownloading
	> FileDownloading
	> UpdateClient
	> Updater
	> Patch/Update Apply
	> Codec
	> Protocol
	> Connection
	> ConnectionAsnyc sync API: disconnect_immediate



libv.update: Patch apply progress report
libv.update: Patch apply current step report (API to get the next step/operation)


update: Sometimes it might require a restart for the updater
	updater is updated -> needs restart
	or migration code is introduced -> need restart to run it, and only after that can the updater continue
	and with that we might enter the dual process updater world

		migration can effect saves, options, configs, profiles or even DB, or install settings or other OS integration stuff
		most of these are resource based so migration happen on demand but some dont (like os)
		so there fore the best option is if the updater code (leave a patch previous version info behind) returns the prev version





app/update/res/gen.sh
app/update/res/apply.sh



libv.utility: input bytes on static memory should return correct amount of read bytes (required by hash_md5)

libv.utility: Storage space size formatter: xxx'xxx.yy KB, MB
		This will absorb the dotter that I have in fsw




libv.update: Upon patch apply failure, create manifest and send to server

libv.update: patch creation rename support
libv.update: patch creation modify to support

libv.update: patch apply LOG EVERY FAILURE, LOG EVERYTHING, that will be useful


cpp: if tellg fails it can return -1, review EVERY usage of it






libv.net, libv.utility, app.update: Looks like the performance of operator<< .rdbuf() might be bad, benchmark and fix it
		| ok, its not that bad, but there is faster, seek + tell + resize + read is faster
		| https://quick-bench.com/q/GLAWAXMThdMGHsagYhSOOR1DBx8
		| ok, its pretty bad, seek and tell is faster for larger inputs
			s.seekg(0, std::ios::end);
			const auto stream_size = s.tellg();
			s.seekg(0, std::ios::beg);
		| but the fastest is a local stack buffer of ~16KB that is filled and processed in a loop
			https://quick-bench.com/q/idbivSAx2upsgoXQQgIPhmsBIJU







Idea: patch on patch: for future patch download, download expected patch, patch the patch when it goes live



Network:

disconnect_immediate()


I could do this when resolving:
udp::resolver::query query(udp::v4(), response[0], response[1]);
						   ^^^^^^^^^


libv.net.mtcp: Protocol messages, handshake with protocol ID and version
	libv.net.mtcp: Symmetric transfer rate limiting (requires storing local and remote limit, use min) (requires protocol message)



app.update: Implement an update server / client
	app.update: Reconnect: attempts, timers

	app.update: Security: Scope restriction on file access
	app.update: Login
	app.update: Server: Cache files in memory, watch if they change

	app.update: Manifest, versions, etc...
	app.update: List current clients on Server

	app.update: Sign the patch (server auth is not needed for now, signing is enough)
			https://eclipsesource.com/blogs/2016/09/07/tutorial-code-signing-and-verification-with-openssl/
			https://gist.github.com/irbull/08339ddcd5686f509e9826964b17bb59


app.update: Version manifest: list of files with MD5 hash in a folder
app.update: Patch manifest: list of changes add/delete/(replace)/modify/rename

app.update: The update process:
	prep
		create release
		server side create diff from
			folder/release A
			folder/release B
		save diff into patch folder with relevant information
		sign the diff
	update
		download diff
		copy update.exe to update.ex_
		apply diff to update.ex_
		rename update.exe to update.bak
		// Only bricking point is here, and even then .bak could be renamed by hand
		rename update.ex_ to update.exe
		restart update.exe
		remove update.bak

app.update.security:
	! must authenticate the server
	! must sign and verify any downloaded content

	https://stackoverflow.com/questions/11580944/client-to-server-authentication-in-c-using-sockets
		The client connects to the server, sending in the user-name (but not password)
		The server responds by sending out unique random number
		The client encrypts that random number using the hash of their password as the key
		The client sends the encrypted random number to the server
		The server encrypts the random number with the correct hash of the user's password
		The server compares the two encrypted random numbers

	boost.asio.ssl
		https://www.boost.org/doc/libs/1_74_0/doc/html/boost_asio/overview/ssl.html
		https://www.boost.org/doc/libs/1_74_0/doc/html/boost_asio/example/cpp11/ssl/server.cpp
		https://www.boost.org/doc/libs/1_74_0/doc/html/boost_asio/example/cpp11/ssl/client.cpp

