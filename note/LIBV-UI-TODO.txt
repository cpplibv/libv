



--- STACK ------------------------------------------------------------------------------------------








--- UI - Layout invalidation -----------------------------------------------------------------------

Need performance data and statistics. Debug overlay for it?

libv.ui: If a child in panel_anchor or panel_full has not been invalidated,
		and the bounds of the panel did not change
		do not layout (calculate dynamic size) that component
		(only issue if the component does have dynamic size, in this case it must be called)

scroll bar change prompts layout, why? should it?
	| it does to recache the bar position
Slider value change should not invalidate layout
	(make it a float region if it must)
	mouse context range remap might be needed!
libv.ui: Make sure that (only) position change does not invalidate layout

libv.ui: Ensure that scroll pane scrolling doent causes any layout invalidation
	if the content of the scroll area size is Dynamic then it causes a Dynamic
	layout query. Otherwise, its good

libv.ui: Fix layout invalidation up propagation possibility (remove access to flags, and provide mark functions)
		markInvalidLayout();
		| Also this logic might punches through floatRegion "layout barriers" that I dont think it should, or is that not a barrier?
libv.ui: Layout optimization: Some layout (like full and anchor) could handle layout invalidation independently, so if 1 child gets invalidated only that child gets to be relayouted
libv.ui: Make sure to invalidate flags after every child is iterated to prevent exception caused false unflagging
libv.ui: Clean up redundant shader codes and add run time (with shader recompile) to switch between debug clip and no clip
libv.ui: current float region setting does not allows clean iteration and position determination of components, this is an issue. For example mouse and render behaviour are separated
libv.ui.layout:	verify what is going on with position change based layout invalidation in float region



--- UI - Scroll ------------------------------------------------------------------------------------

libv.ui: InputField might not does proper CPU culling (at least in ui sandbox legacy tab)

libv.ui: Slider value change should not invalidate layout
			(make it a float region if it must)
			mouse context range remap might be needed!

Scroll pane
	at first frame has different bar size after first move
	bar size jumps to max
	bar can be moved even if everything fits
	currently 100% over-scrolling is allowed, there should be a 0..1 float properaty for it and the default should be 0 in each dimension

libv.ui: Slider "hover" style/state should be separate for the track and the bar

libv.ui: Implement scroll pane anchor behaviour
		anchor = "top-left"

libv.ui: Scroll pane should have properties: font, font_size, scroll_speed: if font is null speed = scroll_speed, otherwise speed = font.height(font_size) * scroll_speed

libv.ui: Scroll pane content background is incorrect, bc content size in incorrect
		might be layout (-1) issue | might have changed already

libv.ui: scroll area in scroll area, nested rendering alters clipping, events and control

libv.ui: scroll area: request_scroll_to(pos, size) or request_display_of(pos, size)
libv.ui: vec2 get_scroll_size() and use in use min(client.get_scroll_size, client.layout_size)

libv.ui: To fix property init
		| scroll bar should not calculate any fucking layout in non layout
		| it does it so it can process mouse event
	libv.ui: Initialize every property in the constructor, or at least by the end of the ctor
	libv.ui: Do not cache bar bounds in value_* functions | or only cache if attached
	libv.ui: Do not use properties outside of callbacks, the values WILL BE incorrect

libv.ui: Padding support in slider (It effects the bar and not the track) (bar could be replaced to component in future anyways)

libv.ui: Create a real scroll_bar = slider + buttons

libv.ui: Enable actual render clipping (debug option to reenable debug cull view?)
		clip planes should be the most generic solution due to multidraw

libv.ui: observation: clip and scroll are two orthogonal features
		general concept: "floating" component that effects render, mouse, (layout)
		general concept: clip component that effects render, mouse, (layout)

Pagination
		Pagination support

		Pagination API
			dynamic change of max size of the components
				and that information should be traficed back to the scroll pane

			struct MyPagedEntryComponent {
				void on_screen();
				void off_screen();

				void assign(MyObject);
			};

			struct PaginationController {
				using entry = MyPagedEntryComponent;

				std::vector<float> entry_positions;
				libv::vec2f position;
				libv::vec2f size;

				libv::vec2f max_extent;
				libv::vec2f trigger_distance;

				int num_loaded;
				int num_keepalive;

				virtual void trigger_load();
				virtual void trigger_load(index);
				virtual void trigger_unload();
				virtual void trigger_seek();
				virtual void trigger_visible_area_changed();
			};

			Pagination<PaginationController, MyPagedEntryComponent> list;

			keep alive with a ring buffer

			on variable item sizes
				store/keep track of every item position that was already loaded
				1 float / item

			on fix item sized, jump around


		Pagination List Component

		But: Pagination != Scroll size solution

Notes for the real scroll bar:
	double value; // current_line
	double value_low; // 0
	double value_high; // num_line
	double value_range; // num_lines_displayed

	double step_scroll; // [mouse wheel] 1 or 3 or settings.scroll_unit
	double step_button; // [button >] 1 or 3 or settings.scroll_unit
	double step_track; // [mouse button on track] 1 or 3 or settings.scroll_unit or inf
	double step_track_interval; // 0.3 or 1 or settings.step_button_hold_interval
	double step_button_hold; // [button > hold per interval] 1 or 3 or settings.scroll_unit
	double step_button_hold_interval; // 0.3 or 1 or settings.step_button_hold_interval
	double step_arrow; // [up/down] 1 or 3 or settings.scroll_unit
	double step_page; // [pageup/pagedown] num_lines_displayed



--- UI - Tooltip -----------------------------------------------------------------------------------

Tooltip
	libv.ui: Implement built-in support for child properties in BasePanel
	libv.ui: Cleanup child property access in Tooltip Container

libv.ui: Tooltips
		UI wide overlay
		Options:
			anchor:
				relative to mouse 1..9 corner
				relative to mouse no follow 1..9 corner
				relative to component 1..9 corner
				relative to screen 1..9 corner
				relative to callback (for 3D objects) 1..9 corner
			anchor clearance:
				left/right/bottom/top pixel count
				? could clearance be solved with tooltip component margin
			alignment:
				1..9 corner
			edge:
				(scroll pane) clipping space
				window
			edge behaviour (per axis):
				overhang
				clipped
				push in axis
				flip to opposite side
			issue: libv.ui: Card layout doesn't call detach when switching between tabs
			DONE issue: Tooltip doesnt relayout when owner relayouts



----------------------------------------------------------------------------------------------------

libv.ui: Make UI a global var, give it init/terminate function (or be implicit inside an UI ctor), kill current context misery (libv::gui alias, libv::ui::gui object)
libv.ui: Adopt libv.re
libv.ui: Move libv.sun overlay_shader_error.hpp to ui

place.it: "Well behaved layout" flag bit could be also used for mouse events

Layout
	libv.ui: Layout2 could also use unlimited-ness like Layout1
		unlimited in a dim = no anchor or alignment allowed in that dimension
			\ fail gracefully, produce a warning and do the only doable anchor/alignment
		and need a back channel to fetch scroll area final virtual size.
		For simplicity a viable shortcut would be to have separate unlimited line layout
		type only for scrollable lists

	SLC
		libv.ui.SLC: Add anchor/layers support (to support scroll pane with overlapping scroll bar)

libv.ui: Merge Flag and StyleState, but in a way where style only bits can be extracted with ease (like top/bottom N bit).



----------------------------------------------------------------------------------------------------

libv.ui: Improve clipping
	libv.ui: Clip with scissor, fallback to stencil if someone want 3D UI on their on accord
	libv.ui: Clip with stencil:
			ui init
				glEnable(GL_STENCIL_TEST);
				glStencilMask(0xFF);

			glStencilOp(GL_KEEP, GL_KEEP, GL_INCR);
			vertex only pass: GL_INCR the stencil on the clip region

			glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
			glStencilFunc(GL_GEQUAL, clipDepth++, 0xFF)
			render every child

			glStencilOp(GL_KEEP, GL_KEEP, GL_DECR);
			vertex only pass: GL_DECR the stencil on the clip region



----------------------------------------------------------------------------------------------------

libv.ui: static_component system (lite)
	libv.ui: Check on the _pastebin/legacy codes for this one
	libv.ui: non-dynamic based panels, aka static_containers (no remove, only auto add)

libv.ui.theme: Property substructure system example: https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#titledpane
		https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#titledpane
		https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#textfield
		https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#typeeffect

properties / style
	libv.ui.property: if fallback value is requested log a warning
	libv.ui.property: dynamic access
	libv.ui.property: solve name/type collusion
		libv.ui.style: either I centralize and static bind every property name to a single type OR i allow multiple different type/value under a single name
	libv.ui.style: Style Sheet / A proper default style or a way to auto assign styles to components would be nice (this is not property fallback, its style sheet fallback.)
	libv.ui.property: typed property registry
	libv.ui.property: optimize property reset: address could be used to lookup

	libv.ui: ctx.synthesize(T::handler_setter(&ToggleButton::state), ...



====================================================================================================


libv.ui: 3D Anchor point layout (input camera) (For labels / UI Components over objects) (Most interesting stuff may happen in update or events)

libv.ui: Font subpixel options: OFF RGB BGR

libv.ui: Stateify every UI component (minimal: hover and focus)
		label
		button
		input_field
		...

libv.ui: Stateify every UI component (extended: active (and selected))
		label
		button
		input_field
		...

libv.ui: Add missing button state switch on off component active release

libv.ui: border fragment = chained/nested background fragments (decorator pattern)

libv.ui: check on that "recent" modification that i just did in ui.context_state to start the frame time at now
	test time values at first frame



libv.ui: Style (resource) async loading
	if the style is used this frame: block
	otherwise load styles (and related resources) based on their priority (optional manual number during style definition) in the background
		resources with multiple priority uses the highest one
	1000: Loading screen
	 100: Main menu
	   0: Default
	-100: Rarely visited scenes (credits, settings)

libv.ui.property: scope / sheet / component type based style rules

libv.ui: Component Image, CheckBox, Slider(for bar) could have a foreground fragment too (layout 1 should switch to that size)

libv.ui: Background fragment
	libv.ui: background to_string's: "Not implemented yet";

	libv.ui: Implement getInnerContentBounds for every component
		DONE: label
		DONE: button
		DONE: input_field

	idea: Multiple fragment interaction?
			render background plane
			render borders (outer shadow/edge)
			render content
			render borders (inner shadow/edge)

libv.ui: Alignment justify should not 'start' at top left but from the orientation's starting point (therefore AlignVertical rate 1.0 for justifieds are incorrect)

libv.ui: Migrate grid layout to the new Margin, Padding, Spacing and Alignment formulas

Cleanup / Implement
	src/libv/ui/component/base_panel_static.*
	src/libv/ui/component/check_box.*
	src/libv/ui/component/file_picker.*
	src/libv/ui/component/radio_button.*
	src/libv/ui/component/radio_group.*

place.it:
	cpp: Virtual inheritance can be a solution for base injection: All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its member initializer list:
			this can kill libv::net::detail::current_io_context
			investigate the runtime cost
			has memory overhead (I think it is merged with vtable ptr, so class already has one its zero)
	idea: bloom_filter usage if there is a 8/16/32 bit implementation of it: Component "signal"-iness per event type



--- Checkpoint ---



libv.ui/libv.ctrl: Keyboard binding display (For useful fun)

libv.ui: Storage system
	libv.ui: UI level storage system
			context().storage<UIUserConfig>() : UIUserConfig&
			should be accessible via UI too
	libv.ui: Component scoped storage system
			context().scoped_storage<FloatFrame>(label) : FloatFrame&
			should be accessible via UI too

libv.ui: UI based file watcher, libv.fsw > queue > ui loop event stage > broadcast
		should be accessible via UI too
		! There is one now for style script tracking, make it more ui-wise

libv.ui: multithreading cooldown for ui frame iteration update callbacks. Aka: once_per_n_frame instead of X ms

libv.ui: IconButton = background + image + text
libv.ui: Button icon support (with left, top, down, right placement), if icon or text is not set, it is skipped

libv.ui: implement base_line alignment: most likely will need a vec2 get_base_line() function

libv.ui: Idea: new raw texture, white with size of 1x1 px BUT on the getters it lies to 0x0 px so it would not effect layouts

libv.ui: The ui should not know about glr, except in shader, context_render code and maybe the overlays

libv.ui: overlay component layout stack highlight

libv.ui: check box
		Clickable elements with a cross in the middle that can be turned off or on.

libv.ui: default style and theme set

libv.ui: Progress bar: Indicate progress by displaying a partially filled bar. 3 main part: bg, bar, spark
 		Progress bar can have unknown max value, have a mode for it
libv.ui: list layout / component
libv.ui: table layout - only the columns and/or rows have size aka (more strict grid)
		An invisible container that lays out children in a specific number of columns. Column width is given by the largest element contained.
libv.ui: not owning container views (list and/or table)



--- libv.ui MVP checkpoint ------------

libv.ui: tab layout = card layout + header buttons
libv.ui: window
		contain other elements. They have a caption (and, just like flows, they lay out children either horizontally or vertically)

libv.ui: menu bar / menu / popup menu
libv.ui: separator / group (bordered and captioned)



--- libv.ui MVP+ checkpoint -----------

libv.ui: OverlayZoom use linearized zoom (like the Camera2 in vm4viewer)
libv.ui: OverlayZoom in control mode should scale "sensitivity" based on zoom

libv.ui: Hide or remove CoreComponent usage from every API (like focus, AccessLayout)
libv.ui: Remove .core() usages wherever possible

libv.ui: InputMask for input field
		struct InputMask {
			virtual void insert(std::string& text, std::string_view insert, size_t insert_pos);
			virtual void remove(std::string& text, size_t remove_pos, size_t remove_size);
			// virtual std::string_view empty();
			// ...
		};

libv.ui: The UI Paper
	Core
			Core Component object containing every state of a given component, derived from CoreComponent
	Component / Handler
			Lightweight stateless handler object of a core component object, derived from Component
	Host
			Stateless event host

	Spacing / Margin / Padding
		Padding:
			Space between the border and the content inside an element
			Part of the component but not part of the component's "content area"
			Part of the background
			Part of the size
			Part of the mouse region
		Margin:
			Space around an element
			Not part of the component
			Not part of the background (Invisible)
			Not part of the size
			Not part of the mouse region
		Spacing:
			In a container space between elements (none on the outside borders, only between elements)
			Container mandated margin (only) between elements
			Not part of the background (Invisible)
			Not part of the component
			Not part of the size
			Not part of the mouse region

	NOTES: fragments
		caption
		bg
		? fg

libv.ui: Idea for over restricted string_2D: if content would exceed limit, just push the lines or characters closer to each other (could be policy driven)

libv.ui: Idea: Zombie state, instead of keeping the dying component in their container move them into a ui global zombie land, they would still point to their parent, but their parent would no longer know about them
			zombie flag (rename / rework / reuse detach also works)
			change removal to be instant (or at least before/during layout step)
			first step of render is to render destroy all zombies
			and detach will just doDetach and remove every zombies from the ui global storage
		What does it solve?
			viewLayouted and viewRendered container management during layouts
			focusable also wins, no need to scan up for detaching parent | or at least traverse will skip obviously wrong candidates
			layout flag would no longer be required
		What issue could it cause?
			? Maaaaaybe something around expecting it inside parent, but, even that



--- "The" backlog ---



component
	libv.ui: possible component list https://en.wikipedia.org/wiki/Widget_(GUI)
	libv.ui: Splitter
	libv.ui: group: RadioButton
	libv.ui: Component ideas from other systems
	libv.ui: Docker layout with movable components (frames), who handles which responsibility? Think about it and postpone this task


		button	 			Clickable elements.
		sprite-button	 	A button that displays an image rather than text.
		checkbox	 			Clickable elements with a cross in the middle that can be turned off or on.
		flow					Invisible containers that lay out children either horizontally or vertically.
		frame	 			Grey semi-transparent boxes that contain other elements. They have a caption, and, just like flows, they lay out children either horizontally or vertically.
		label	 			A piece of text.
		progressbar	 		Indicate progress by displaying a partially filled bar.
		table	 			An invisible container that lays out children in a specific number of columns. Column width is given by the largest element contained.
		textfield	 		Boxes of text the user can type in.
		radiobutton	 		Identical to checkbox except circular.
		sprite	 			An element that shows an image.
		scroll-pane	 		Similar to a flow but includes the ability to show and use scroll bars.
		drop-down	 		A drop down list of other elements.
		list-box	 			A list of other elements.
		camera	 			A camera that shows the game at the given position on the given surface.
		choose-elem-button	A button that lets the player pick one of an: item, entity, tile, or signal similar to the filter-select window.
		text-box				A multi-line text box that supports selection and copy-paste.
		slider				A number picker.
		entity-preview		A preview of an entity.
		split-pane
		tab-pane
		property-lib:
				auto& c = tree.category("xy")
				auto& p = c.add("zw", new property_int{})
				auto& p = c.add("zw", new property_choice{"enum0", "enum1", "enum2"})
				p.value = 42;

atlas
	libv.ui: texture atlas definition/parsing
	libv.ui.atlas: ui theme atlas loading and auto-preview, semi-auto atlas definition
	libv.ui: support atlas based images

ui
	libv.ui: if ui size .x or .y is 0, do not execute anything from ui loop (frame buffer protection)
	libv.ui: fragments, sub component reusable codes
	libv.ui: ContextConfig
	libv.ui: ContextFileWatcher
	libv.ui: ContextLoopExecutor: any_thread_callable_cb = context.loop.callback_as_event(my_event_callback)
	libv.ui: ContextExecutor
		libv.ui: idea: A component could signal the UI if it want to execute a heavy computation task before (attach, layout, create, render, destroy)
		libv.ui: async_task<T> work_async(const function<progress_report(multi_entry_call, stop_token)>& task);
	libv.ui: ContextStat (not ContextState, stat is for ui statistics)
	libv.ui: mark remove is non-sense for static component system, or composite objects, hide it
	libv.ui: idea: For (debug overlay) UI 2D picker use the mouse wheel with indication beside the cursor to select underlying components

cleanup
	libv.ui: context_resource and libv.gl:image verify that targets are matching the requested target (2D)
	libv.ui: fatal log before every assert

mouse
	libv.ui: mouse events should consider depending on if the window is focused or not | non trivial either way, might be best to have both option dynamically | need this as component level dynamically (camera controls need global, for other ui actions local is enough)
	libv.ui: unchanged - updating watcher (any property) without change should not yield any event | do I care about it?

event
	libv.ui: if 'everything' 'above' is done re-read the requirements of mouse events and verify if all of them are met | context_mouse.cpp
	libv.ui.event: mouse/keyboard/joystick ability to query sub-frame resolution of press/held/release cycle. Time the events (it will be a lot of timestamp)
	libv.ui.event.host: UI global event host (optional) support for component hierarchical up-walking iteration over handlers
	libv.ui.event.host: UI component hierarchically scoped custom event host (just like UI global)

interactive
	libv.ui: Ability to select, copy or click link from Labels if the specific properties are set to allow it

	libv.ui: Cursor image change
	libv.ui: Make a sandbox for a input->button->label->list
	libv.ui: mouse drag and drop system

	libv.ui.input_field: Implement FocusSelectPolicy
	libv.ui.input_field: Implement NewLine/MultiLinePolicy
	libv.ui.input_field: if text does not fit, crop/layer it and only display around caret
	libv.ui.input_field: if text does not fit, display a popup with full text on mouse hover and idle
	libv.ui.input_field: input mask (this will possibly a different input_field type)
	libv.ui.input_field: mask('*') for passwords
	libv.ui.input_field: mouse hover cursor change to cursor-caret symbol
	libv.ui.input_field: multi_line(true)
	libv.ui.input_field: selection support
	libv.ui.input_field: multi-selection support
	libv.ui.input_field: synthesize selection property
	libv.ui.input_field: synthesize multi-selection property
	libv.ui.input_field: text function call should produce event
	libv.ui.input_field: background_shadow_tip_string("Password")
	libv.ui.input_field: tip_string("Generic password related tip")
	libv.ui.input_field: undo/redo support
	libv.ui.qol: On selecting a file name input field the caret should be placed before the extension and select the basename (even if the click is after the dot), but for a second click it should jump where it is requested

ctrl
	libv.ui.ctrl: ui.focus-backward = shift+tab
	libv.ui.ctrl: ui.focus-forward = tab
	libv.ui.ctrl: ui.focus-tab-backward = ctrl+shift+tab
	libv.ui.ctrl: ui.focus-tab-forward = ctrl+tab
	libv.ui.ctrl: ui.new-line = enter
	libv.ui.ctrl: ui.select = space
	libv.ui.ctrl: ui.send = enter
	libv.ui.ctrl: ui.send = kp-enter
	libv.ui.ctrl: ui.send-alt = shift+enter
	libv.ui.ctrl: ui.send-alt = shift+kp-enter
	libv.ui.ctrl: ui.text.cursor-down = down
	libv.ui.ctrl: ui.text.cursor-left = left
	libv.ui.ctrl: ui.text.cursor-right = right
	libv.ui.ctrl: ui.text.cursor-up = up
	libv.ui.ctrl: ui.text.jump-end = end
	libv.ui.ctrl: ui.text.jump-home = home
	libv.ui.ctrl: ui.text.remove-backward = backspace
	libv.ui.ctrl: ui.text.remove-forward = delete
	libv.ui.ctrl: ui.text.remove-word-backward = ctrl+backspace
	libv.ui.ctrl: ui.text.remove-word-forward = ctrl+delete
	libv.ui.ctrl: ui.text.select = lmb [hold]
	libv.ui.ctrl: ui.text.select-left = shift+left
	libv.ui.ctrl: ui.text.select-right = shift+right
	libv.ui.ctrl: ui.text.select-word = lmb, lmb
	libv.ui.ctrl: ui.text.select-word-left = ctrl+shift+left
	libv.ui.ctrl: ui.text.select-word-right = ctrl+shift+right
	libv.ui.ctrl: ui.redo = ctrl+[y] // logical y key
	libv.ui.ctrl: ui.undo = ctrl+[z] // logical z key
	libv.ui.ctrl: ui.redo-non-destructive // emacs style redo, not the default
	libv.ui.ctrl: ui.undo-non-destructive // emacs style undo, not the default

overlay
	libv.ui: generic orthogonal component level overlay system
		libv.ui: overlay ui errors/warnings: A generalized ui error report system (console with extras)

		libv.ui: overlay event freeze
			libv.ui: overlay event grab / multi-root / fake-root / overlay focus shaky
			libv.ui: overlay controls / mode switches / overlay mode display / overlay control display

		libv.ui: overlay zoom
			libv.ui: pixel distance measure / pixel region measure

		libv.ui: overlay cursor pixel highlight, coordinate display and mouse region stack display
		libv.ui: overlay magnifier (local zoom) (optionally slow mouse movement speed (freeze cursor with frame))
		libv.ui: overlay (mouse) stack display
		libv.ui: overlay component tree display
		libv.ui: overlay debug data stream, a context based output that can be written and displayed as a HUD

		libv.ui.property: hybrid reflection - dynamic
			libv.ui: detach should also be an event (mouse_table could utilize it to cleanup, debug observers could also use it)
				libv.ui: overlay property inspector (name it inspector)

		libv.ui: overlay resource viewer (textures, fonts, shaders (?))

lua
	libv.ui: lua binding | or rather a lua component or prototype parsing
	libv.ui: make sandbox_ui.lua work

libv.ui: include check everything / fwd everything
libv.ui: statistics: each ui operation (attach, style, render, ...) histogram, min, max, count | maybe not store, only give an option to log the current values each frame, maybe with a default stat collector

libv.ui.font: font failure to load means fallback | verify
libv.ui.shader: shader failure to load means fallback | verify
libv.ui.shader: shader dynamic loading from file

libv.ui.font: fallback to Unicode Character 'REPLACEMENT CHARACTER' (U+FFFD) | add it back to fallback consolas_min font | https://www.fileformat.info/info/unicode/char/fffd/index.htm
libv.ui.font: fallback to ascii '?'
libv.ui.font: fallback to simple square (render the not found character by 'hand')
libv.ui.font: https://www.freetype.org/freetype2/docs/tutorial/step2.html
libv.ui.font: We do not check the error code returned by FT_Get_Kerning. This is because the function always sets the content of delta to (0,0) if an error occurs.

libv.ui: String2D scream at the user if the API get a \r (or any non printable character beside \n \t), and ignore it



--- Theme ---

https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/TableView.html
table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

imageHolder.minWidthProperty().bind(Bindings.createDoubleBinding(() ->
        scroll.getViewportBounds().getWidth(), scroll.viewportBoundsProperty()));
    grid.getChildren().add(imageHolder);

app.theme: use event_reentry_guard in control.slider.event().change
app.theme: create theme exporter: json and atlas texture

app.theme: connect the theme gen with a running app to live update
app.theme: clean up C++ blend/effect implementations

glow falloff is incorrect on corners, find a better solution
	idea: it is 0-1 1-0: in the first range falloff should be a noop bc those values can be considered 1 AA
	libv.ui: Overlay zoom mouse hovered pixel color display
	| size = 0, falloff = 1 highlight perfectly the affected pixels

app.theme: --- PAPER ---
	So the way theme generation works (plan):
	- lua script containing the styles incl properties and the recepies for the atlases
	- running the lua script from C++ will generate the atlases and export it into an image and another lua script
	- from c++ ui run the generated lua script to acquire the theme
	- | NOPE
	- 	-> I will not generate lua from lua, that would not make sense, but what would make sense, is to generate a hash from the lua and if the hash matches the atlas...


=== PAPERS ========================================================================================


Alternatives:
		--- elements ---
		https://github.dev/cycfi/elements
			Composition and properties are based on a decorator pattern

		Observations:

		composition:
			elements achieves good composition by a decorator pattern
			in case of composite components (like slider) it uses memory local storage
				with virtual functions to access parts
				virtual & rail

		elements have no property system, everything is composed via a decorator pattern

		--- nana ---
		https://github.com/cnjinhao/nana
			Great event system API




PAPER: Re-entering event loop problem and solution:
	Solution event_reentry_guard:
		On every call execute 2 step:
			- Test Target. If it fails abort early
			- Lock Source

	Example:
		// In the ui -> model event handler:
		const auto reentry_guard = input.event_reentry_guard(source_component.ptr(), &target_model);
		if (!reentry_guard)
			return;

		// In the model -> ui event handler:
		const auto reentry_guard = input.event_reentry_guard(&source_model, target_component.ptr());
		if (!reentry_guard)
			return;

	Second solution idea (not yet implemented):
		Have a second function for every function that could result in an event broadcast
		text(), text_silent()
		value(), value_silent()


PAPER: Component styled states:
		Possible states:
			Button
				 Disabled : Normal : Hover : Focus : Active(Pressing) : Progress : Done/Error

			Input Field
				 Disabled : Normal : Hover : Focus

			Slider
				 Disabled : Normal : Hover : Focus : Active(Dragging)

		- states are independent
			bit-mask
			limited number of state (max 32)
			state names has to assigned to a unique int

		- state def in style sheet
				ui.style("style.name") {
					properties...

					state("[!]state{, [!]state}") {
						conditional properties...
					}
				}

		- overriding: in case of multiple definition of the same property the last with matching state wins

		- inheritance: If the requested property is not found the parents will be searched recursively



PAPER: SLC - Static Layout Composition
	Node input / output:
		area_size: The full size of the area that the node should consider
			- For pixel / percent its the full conainer size
			- For dynamic its the maximum limit the node could use (including its current reserverarion)
			- For ratio its the exact new size (determined by ratio) of the node
		return: Change in reservation in the area

	Rules:
		These rules have been changed compared to the original rules
		to better match necessary capabilities.

		Pixel size:
			Fix (minimal) size in pixels
		Percent size:
			Percent size of the parent excluding the padding
		Dynamic size:
			Limit = assume every future dynamic is empty
			Can "reuse" space already allocated by the objects fix size
		Ratio size:
			Distribute any unused space between nodes based on their ratio





Heritage:
	struct FontEffect {};
	struct FontFamily {};
	struct FontSize {}; //font-size/line-height
	struct FontStyle {}; //font-style - Specifies the font style. Default value is "normal". See font-style for possible values
	struct FontVariant {}; //font-variant - Specifies the font variant. Default value is "normal". See font-variant for possible values
	struct FontWeight {}; //font-weight - Specifies the font weight. Default value is "normal". See font-weight for possible values
	text						The text to display in the label. The text can contain newlines.
	NoTextInteraction			No interaction with the text is possible.
	LinksAccessibleByKeyboard	Links can be focused using tab and activated with enter.
	LinksAccessibleByMouse		Links can be highlighted and activated with the mouse.
	TabIndex / Focusable		If true, the widget accepts input focus. The default is false. (takeFocus/TakeFocus)
	TextSelectableByKeyboard	Text can be selected with the cursor keys on the keyboard.
	TextSelectableByMouse		Text can be selected with the mouse and copied to the clipboard using a context menu or standard keyboard shortcuts.
	horizontally_stretchable	If the GUI element stretches its size horizontally to other elements
	vertically_stretchable		If the GUI element stretches its size vertically to other elements
	horizontally_squashable		If the GUI element can be squashed (by maximal with of some parent element) horizontally This is mainly meant to be used for scroll-pane The default value is false
	vertically_squashable		If the GUI element can be squashed (by maximal height of some parent element) vertically This is mainly meant to be used for scroll-pane The default (parent) value for scroll pane is true, false otherwise
	cell_spacing				Space between the table cell contents and border.
	horizontal_spacing			Horizontal space between individual cells.
	vertical_spacing			Vertical space between individual cells.
