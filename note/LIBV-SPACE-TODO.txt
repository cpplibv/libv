
Space - System integration demo

libv.rev: Implement shader management
app.space: Improve arrow with geometry shader
app.space: Add grid
visual.grid: Make a pretty grid: Blender grid is awesome. Implement it:
visual.grid: For grids expand and fade out line endings
visual.grid: For grids fade out lines based on ray incident angle, lines should fade into the sky-box as seamlessly as possible
visual.grid: For grids fade out small lines based on distance from the camera and make higher grid lines more visible
visual.editor_bg: Non uniform color, use a grainy texture (like blue noise)
app.space: Move origin gizmo into top right corner into screen space
app.space: Burn a frame icon set into the binary and use it
app.space: Have space working from the correct dir
app.space: Screen picker integration - Place something onto the 3D world on mouse click
app.space: Fleet that moves (without any arrow)
app.space: Cleanup the shader error overlay code (PanelStatusLog + UIEventHub)
app.space: Sim state manipulation only with commands
app.space: Fleet with arrow and movement toward target (primitive)
app.space: Add support for command arrow 'intent' (color) specification
app.space: Revive the original debug arrow spiral
app.space: Implement a more complete test arrow set (parallel, different length, star, spiral, rings, multiple chains with different rotation angles)
app.space: Add support for command arrow animation offset
app.space: Add support for chained command arrows
app.space: Basic hacky networking
libv.ui: Add overlay events to the global events, then use those to alter controls input ignore (attach can auto do this)
app.space: Cannibalize style.lua from vm4_viewer






































--- STACK ------------------------------------------------------------------------------------------



generate some source?
	https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/

	add_executable(generator generator.cpp)

	add_custom_command(
		OUTPUT  generated.cpp
		COMMAND generator ${CMAKE_CURRENT_BINARY_DIR}/generated.cpp
		DEPENDS generator someInputFile.cpp.in
	)

	add_executable(myapp
		main.cpp
		${CMAKE_CURRENT_BINARY_DIR}/generated.cpp
	)



place.it:
	ux: Game opening sound (menu music or intro animation) is extremely important, it should always be pleasant and not intrusive
	ux: On actions that are meant for list entries (delete or edit list element) the action should be placed in the row. Selecting an entry then pressing a button on a different location on the UI is very cumbersome
	libv.sys: Move clipboard text to it from libv.ui.context_ui

	lua: Install luacheck and setup it in CLion https://github.com/mpeterv/luacheck

git:
	Change the author of these commits:
	* 2021-08-27 app.space: Implement fleet movement queue  Császár Mátyás [Vader]
	* 2021-08-17 review - app.space: Command arrow chains  Császár Mátyás [Vader]
    * 2021-08-17 review - app.space: Progress on command arrow animation offset  Császár Mátyás [Vader]
    * 2021-08-16 review - app.space: Implement a more complete test arrow set  Császár Mátyás [Vader]
    * 2021-08-16 review - app.space: Revive the original debug arrow spiral  Császár Mátyás [Vader]
    * 2021-08-15 review - app.space: Add support for command arrow 'intent' (color) specification  Császár Mátyás [Vader]


app.space: Cannibalize config.hpp from vm4_viewer (but maybe change it to CTRP, investigate it)

app.space: Simulation time control
	app.space: Pause, Unpause (It will be a good practise for timers and controls)
	app.space: Speed x1 x2 x4

app.space.net: Networking
	app.space.net: Networking (Stage 2)
		app.space.net: Introduction, Name
		app.space.net: Lobby
			app.space.net: List of connected clients and their state

	app.space.net: Networking (Stage 3)
		app.space.net: Snapshot
			app.space.net: Snapshot saving
			app.space.net: Snapshot sending upon newly connected client (with pause)
			app.space.net: Snapshot loading
			app.space.net: Non paused snapshot join
				app.space.net: Fast forwarding after a snapshot loading happened
				app.space.net: Apply, update, skip render repeat until catch up
			app.space.net: [Optional] Snapshot delta to help catchup

	app.space.net: Networking (Stage 4)
		app.space.net: Latency hiding

	app.space: Mini canvas show other clients view (Needs lobby)

app.space: Simulation
	app.space: On fleet command completion in chain: Do not waste energy, roll the excess 'movement time' into the next command

app.space: Fleet merge/follow/attack commands
	app.space: 3D fleet picking
	app.space: 3D secondary fleet picking
	app.space: Fleet selection, selection based commands
	app.space: Multi fleet selection
	app.space: 3D fleet box selection
	app.space: Fleet factions



Solved:
	- How does network interfaces with the playout logic? | Reference and codec, but a lot of thing is unclear
	- How does UI interfaces with the business logic? | Nexus
	- How does UI accesses business state? | References and Nexus subscriptions






app.space: Main structure paper

	game instance (desktop) - GameInstance (an object spawned when you launch the application and that remains the same until you close it)
		frame
		controls
		nexus
		settings
		user/player
		ui
		ui main (mp bar, shader overlay)
			renderer(s)
			session (aka old game mode) - GameSession (spawned when a level is loaded)
				[Network base]
				[Network server]
				[Network client]
				gamemode (aka new control concept)
				universe - GameState (spawned by the gameMode)
				playout
				canvas
					& renderers
				ui session (cmd bar)
				ui session mp (mp mini canvas list)

				PlayerController [UI, Controls]
					PlayerState (spawned when a PlayerController is spawned = when a player arrives in the game)







app.space: Structure the whole program: UML time is upon us

app.space: Self-Updater

app.space: frustum visualization
app.space: Add multi camera / camera frustum visualization (uniforms and C++ clipping from the main camera, but view from another)
app.space: Camera: Pressing the camera alteration in one direction for long time (>1-3s) increase speed

app.space / libv.rev: Render target/Framebuffer abstraction
		ms / ss support
		depth support
		easy render target inspection
app.space: make a blur or a bloom

app.space: Optimized VAO update for command arrows (prepare / render step is done, mesh re-upload and glr side should be checked)

app.space: Command arrow improvements
	app.space: Add support for source position offset (Instead of origin use an offset toward the heading direction)
	app.space: Add support for target position offset (Instead of origin use an offset from the incoming direction)
	app.space: Arrow strip placement control from lua (or something lua related) (With auto reload and everything)
	app.space.visual: Command arrow add a glossy holo texture (~simple cloud mixture) to the arrows body (idea come from flowstorm's checkpoint body)
	app.space.visual: Command arrow make the edges less bright to help with AA edge

app.space: line shader (Dalma)

app.space: Iris and space has to merge in some way

game.sim:
		- Command based sim state manipulation | Playout
			Types:
			- Control tracking (Camera / Mouse movement, ?Selection)
			- Sim state manipulation (Move, Attack, Production command, ?Selection)
			- Session manipulation (Permission alteration, Kick, Ban, etc)

app.space: headless server
	To optimize the binary size and skip linking in shit for headless,
	a separate executable needed without any symbol usage of non-headless gamemode



visual.shader: glow net: https://www.youtube.com/watch?v=3CycKKJiwis

libv.rev: 'Global' uniforms: read what unity has to offer https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html

watch shader part 3 https://www.youtube.com/watch?v=E4PHFnvMzFc


What do I need from libv to make a 'minimal' working iris program?

	libv.update
		Resource
			1 Working resource download protocol
			1 Update/Resource signature verification
		Working update
			1 Self update support
			1 Marry Resource and Update
		Deployment
			2 Scripts to create a new build and deploy to libv.update servers

	libv.serial
		1 safe container resize/reserve

	libv.ui
		1 background generalization
		2 list component
		3 scroll pane = scroll area + scroll bar + connecting them
		4 button states (state styles)
		5 font outline render
			freetype2 Now has SDF
			spread property set:
				const FT_Int spread = 8;
				FT_Property_Set(library, "sdf", "spread", &spread);
				8bit uint normalized to [+spread .. -spread]

iris: Make a main menu

blur: (shaders are already implemented in app.space, but downscaling is not) https://www.youtube.com/watch?v=uZlwbWqQKpc
		full screen quad pass with render_resolution / 2 with v blur shader
		full screen quad pass with render_resolution / 2 with h blur shader
		full screen quad pass with render_resolution / 8 with v blur shader
		full screen quad pass with render_resolution / 8 with h blur shader


game.architect: Networking: To get a free networking integration prepare simulation in a way, that any input action is serialized into data/message first, then apply that data/message



--- Article collection -----------------------------------------------------------------------------

Infinite Grid: http://asliceofrendering.com/scene%20helper/2020/01/05/InfiniteGrid/
CMake source generation step: https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/
