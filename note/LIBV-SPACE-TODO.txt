
Space - System integration demo

libv.rev: Implement shader management
app.space: Improve arrow with geometry shader
app.space: Add grid
visual.grid: Make a pretty grid: Blender grid is awesome. Implement it:
visual.grid: For grids expand and fade out line endings
visual.grid: For grids fade out lines based on ray incident angle, lines should fade into the sky-box as seamlessly as possible
visual.grid: For grids fade out small lines based on distance from the camera and make higher grid lines more visible
visual.editor_bg: Non uniform color, use a grainy texture (like blue noise)
app.space: Move origin gizmo into top right corner into screen space
app.space: Burn a frame icon set into the binary and use it
app.space: Have space working from the correct dir
app.space: Screen picker integration - Place something onto the 3D world on mouse click
app.space: Fleet that moves (without any arrow)
app.space: Cleanup the shader error overlay code (PanelStatusLog + UIEventHub)
app.space: Sim state manipulation only with commands
app.space: Fleet with arrow and movement toward target (primitive)
app.space: Add support for command arrow 'intent' (color) specification
app.space: Revive the original debug arrow spiral








































--- STACK ------------------------------------------------------------------------------------------




update
	playout.update
	universe.update

Clear Fleet




- main issues needs resolution is how to package user data into a ui component
and how those two should share lifetime

- object and component ownership coupling



game instance (desktop)
	frame
	controls
	nexus
	settings
	user/player
	ui
	ui main (mp bar, shader overlay)
	renderers
	session (aka old game mode)
		[Network base]
		[Network server]
		[Network client]
		gamemode (aka new control concept)
		universe
		playout
		canvas
			& renderers
		ui session (cmd bar)
		ui session mp (mp mini canvas list)







2 main question needs resolution
	- How does UI interfaces with the business logic
	- How does network interfaces with the playout logic

Options for UI:
	Interface
	Interface + Inheritance
	Object with everything in it
	Nexus
	Console

Nexus is most likely the best choice
	question: how UI accesses state

I might two listener types: action and reaction
	action is needed to enforce it runs before and reaction
		this would allow 'request' type events where instead of executing then notifying it requests, executes and notify

it would mean 3 main function in the Nexus
	broadcast<E>
	action<E>
	listen<E>

fuck 3: make it 2, broadcast and connect
	action / listen split shall be implemented with a different event type, for multiplayer and delay and other reasons

UI would also have to react to its own initiation

'mp-bar' and 'shader-overlay' are persistent between game_sessions, 'cmd-bar' and canvas are not



GameInstance (an object spawned when you launch the application and that remains the same until you close it)
	GameSession (spawned when a level is loaded)
		GameState (spawned by the gameMode)
		PlayerController [UI, Controls]
			PlayerState (spawned when a PlayerController is spawned = when a player arrives in the game)



architecture: 'MSSVC'
	- Model
	- Simulation
	- Syncronization
	- View
	- Control




app.space: Structure the whole program: UML time is upon us
app.space: Pause, Unpause (It will be a good practise for timers and controls)

app.space: Networking: Mouse, Camera, Fleet, Chat commands sharing
app.space: Mini canvas show other clients view

app.space: Cannibalize config.hpp from vm4_viewer (but maybe change it to CTRP, investigate it)
app.space: Cannibalize style.lua from vm4_viewer

app.space: Self-Updater

app.space: frustum visualization
app.space: Add multi camera / camera frustum visualization (uniforms and C++ clipping from the main camera, but view from another)
app.space: Camera: Pressing the camera alteration in one direction for long time (>1-3s) increase speed

app.space / libv.rev: Render target/Framebuffer abstraction
		ms / ss support
		depth support
		easy render target inspection
app.space: make a blur or a bloom

app.space: Optimized VAO update for command arrows
app.space: Iris and space has to merge in some way

app.space: line shader


app.space: Command arrow improvements
	app.space: Add support for command arrow animation offset
	app.space: Add support for chained command arrows
	app.space: Add support for source position offset (Instead of origin use an offset toward the heading direction)
	app.space: Add support for target position offset (Instead of origin use an offset from the incoming direction)
	app.space: Implement a more complete test arrow set (parallel, different length, star, spiral, rings, multiple chains with different rotation angles)

	app.space: Arrow strip placement control from lua (or something lua related) (With auto reload and everything)


game.sim:
		- Command based sim state manipulation
			Types:
			- Control tracking (Camera / Mouse movement, ?Selection)
			- Sim state manipulation (Move, Attack, Production command, ?Selection)
			- Session manipulation (Permission alteration, Kick, Ban, etc)

app.space: headless server
	To optimize the binary size and skip linking in shit for headless,
	a separate executable needed without any symbol usage of non-headless gamemode


app.space.visual: Command arrow add a glossy holo texture (~simple cloud mixture) to the arrows body (idea come from flowstorm's checkpoint body)

visual.shader: glow net: https://www.youtube.com/watch?v=3CycKKJiwis

libv.rev: 'Global' uniforms: read what unity has to offer https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html

watch shader part 3 https://www.youtube.com/watch?v=E4PHFnvMzFc


What do I need from libv to make a 'minimal' working iris program?

	libv.update
		Resource
			1 Working resource download protocol
			1 Update/Resource signature verification
		Working update
			1 Self update support
			1 Marry Resource and Update
		Deployment
			2 Scripts to create a new build and deploy to libv.update servers

	libv.serial
		1 safe container resize/reserve

	libv.ui
		1 background generalization
		2 style lua loader
		2 list component
		3 scroll pane = scroll area + scroll bar + connecting them
		3 container spacing property
		4 button states (state styles)
		5 font outline render

iris: Make a main menu

blur: (shaders are already implemented in app.space, but downscaling is not) https://www.youtube.com/watch?v=uZlwbWqQKpc
		full screen quad pass with render_resolution / 2 with v blur shader
		full screen quad pass with render_resolution / 2 with h blur shader
		full screen quad pass with render_resolution / 8 with v blur shader
		full screen quad pass with render_resolution / 8 with h blur shader


game.architect: Networking: To get a free networking integration prepare simulation in a way, that any input action is serialized into data/message first, then apply that data/message



--- Article collection -----------------------------------------------------------------------------

Infinite Grid: http://asliceofrendering.com/scene%20helper/2020/01/05/InfiniteGrid/

