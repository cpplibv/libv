
Space - System integration demo






--- STACK ------------------------------------------------------------------------------------------



Evolving an Actor Library Based on Lessons Learned from Large-Scale Deployments - Benjamin Hindman
https://www.youtube.com/watch?v=P6Y-Z1uPp4c

Back to Basics: Concurrency - Mike Shah - CppCon 2021
https://www.youtube.com/watch?v=pfIC-kle4b0


visual.shader: glow net: https://www.youtube.com/watch?v=3CycKKJiwis












ui
	libv.ui: color picker
	libv.ui: gradient picker
	libv.ui: components
		libv.ui: accordion
		libv.ui: drop down
		libv.ui: number input
		libv.ui: number slider
		libv.ui: color input
			libv.ui: color picker
		libv.ui: gradient input
		libv.ui: tabs (card layout with controls)
	libv.ui: default style sheet



libv.mt: worker thread group support for launching the same tasks for multiple thread
star: Settings page back clear the focus while apply will rotate it to next

cereal: visiting_archive




New and shinny simulation snapshot
	codec only uses a simple tag type ()
		rest of the snapshot payload left inside the archive

	fixate some types around networking
		vector<byte>

	snapshot version could travel inside the tag and inside the archive
		new versioned archive

	simulation would load/save the state directly into an archive
		BUT snapshot would have to still travel through the playout systen
			movable archive
			movable message

	BUT THERE MUST BE A JSON DEBUG VISUALIZATION FOR SNAPSHOT



Playout API needs the CTO's to be base classed so it does not include the serialization on API
	CTO base class means code generation
	BASE CLASS IS NOT MANDATORY, but a concept for CTO should include a serialization function


UNDO SYSTEM
	CTO's and playouts create a command pattern which should be able to handle
	the undo system too
	Command {
		int properties_to_execute = 42;
		int previous_state_stored_here_for_undo;

		execute() {
			do_execute(properties_to_execute)
			previous_command_value_stored_here_for_undo = value
		}
		undo() {
			do_execute(previous_command_value_stored_here_for_undo)
		}





Simulation
	app.space: Simulation (container / master controller object)
				A new container object/class that has the universe in it
				Process functions are the member of the simulation
		app.space: Rename universe folder to simulation

	app.space: Simulation time control
		app.space: Fix time step
		app.space: Pause, Unpause (It will be a good practise for timers and controls)
		app.space: Speed x1 x2 x4
		app.space: Speed hotkeys: 0,1,2,3 = set, space = toggle pause and last non pause speed






libv.utility: entity_store: cheap non alloc default ctor | this would allow usage after moved from


app.space: Selection state storage
		selectedFleetIDList have to die, or became a better index










https://www.youtube.com/watch?v=pfIC-kle4b0



Options
	app.space: Debug views and grid on/off (and other options) with persistence


entity_ptr
	libv.utility: entity_store context_ptr: rename current context ptr to store_ptr and (re)introduce a context_ptr
	app.space: entity_ptr circular reference leak mitigation ideas:
		- have a primary owning ptr version too, which is
				- move only
				- can create (normal) view references
				- will call kill() if dtored
		- kill could auto use the serialization to discover entity_ptr-s with another archives

app.space: Make snapshot_ptr_resolver.hpp not include the whole cereal.hpp

app.space: During shutdown do not broadcast client disconnections one-by-one to others, but drop every connection at the same time

app.space: Low Performance P4: app.space: 200*200 debug sphere causes low fps
		| debug shapes have to switch to pre-uploaded meshes
		| and instanced rendering

app.space: Bug P4: crash with assert
	open server
	client 1 join
	client 2 join
	server -> join (switch to client mode)
		Assertion failed: false && "Internal consistency error", file E:/dev/cpp/libv/app/space/view/scene_mp_status.cpp, line 55


-----------------------------------------------------------------

app.space: Formation
		Float, slight movement, perlin noise based on position? and or time
		Single ship join the fleet
		Fleet-fleet merge

-----------------------------------------------------------------

TODO P1: Shortcut to save camera position and reload it upon restart
         > Requires persistence
TODO P1: Auto runtime hook option for random uniform variables
TODO P1: Persist auto runtime hook options
         > Requires persistence



app.space: Controls: Clicking on shuffle button deselects
		| feature_binary_raii
app.space: Controls: Ctrl box selection support
			| Maybe enough if we switch to binary feature for now
				Good start, but need some working on the conflicts
app.space: Controls: Clicking and rotating the camera it deselects
		| Should analog features have priority over action/binary?
				Or does (0,0) 'magic' happens and that causes the issue?
app.space: Controls: Canvas controls should be more eager even it canvas is not focused it noone else grabs it input it should

Main areas of focus:
	60 / 4: Library: State machine generation
	12 / 4: Library: Shader / Uniform block generation
	libv.gen: CMake wish integration to predetermine generated output source files
			wish_create_exe(
				Generator src/to/dir/**.in.lua
			from that "Generator src/to/dir/**.in.lua" is executed in multiple steps
				first step is only inspection to determine generated output files at configure time
				second step is simple generation during build time
				we might need a fake target that reruns the cmake if the output files list changes
						^ and actually this is the hard part
					\ Maybe start a daemon or be a daemon that is started at first compilation (shut it down after X min of inactivity)
							\ still requires everything
				Maybe output a .cmake file that is included that only contains the output files

	app.space: Visual: Fleet selecting 4 corner animation / highlight effect

	app.space: Galaxy generation (scripted)
	app.space: Main menu
	app.space: In game menu
	app.space: Multiplayer lobby list
	app.space: Map generation with lua



libv.rev: PostProcess should respect original framebuffer and viewport values




place.it:
	ranges chunk, pairwise and slide (might be in ranges::v3, but planned to come with C++23)
		std::views::chunk(column_count)
			could replace the column count view used by ui grid
		std::views::pairwise
		std::views::slide(number_of_nlets)
			could replace the adjacent_pair algo is called with number_of_nlets=2

	fmt::print("{}", container);
	fmt::print("{}", container | view::join(":"));



app.space.net: Networking
	app.space.net: Networking (Stage 3)
		app.space.net: Connection stages and states
		app.space.net: Snapshot
			app.space.net: Snapshot saving
			app.space.net: Snapshot sending upon newly connected client (with pause)
			app.space.net: Snapshot loading
			app.space.net: ? Non-snapshot data members (fleet selection)
		app.space.net: Smooth Snapshot
			app.space.net: Non paused snapshot join
				app.space.net: Fast forwarding after a snapshot loading happened
				app.space.net: Apply, update, skip render repeat until catch up
			app.space.net: [Optional] Snapshot delta to help catchup
		app.space.net: Snapshot compression above X KB (64)

	app.space.net: Networking (Stage 4)
		app.space.net: Deterministic execution (Frame Index and lockstep)
		app.space.net: Latency prediction
		app.space.net: Latency hiding

	app.space.net: Networking leftovers
		app.space.net: Timer to kick "connectings" after X sec if they dont identify (Intro) themselves
		app.space.net: Implement lobby status event
		app.space.net: Implement lobby chat message event
		app.space: Mini canvas show other clients view



app.space.net: Networking PAPER:
	Some random buzz words:
		Deterministic lockstep
		snapshot
		delta update
		playout delay buffer
		adaptive playout delay











app.space: Simulation
	app.space: On fleet command completion in chain: Do not waste energy, roll the excess 'movement time' into the next command



app.space: RendererDebug
	DONE: color property
	DONE: line, triangle, quad, disc
	DONE: sphere:
		DONE: UV sphere, tessalation in renderer.cpp instead of canvas.cpp
    DONE: frustum: 5 points, 1 quad, 4 sides
    circle, [box]
    plane
    2D shapes in screen space(rectangle)
	--------------
	orientation (aka gizmo with colored endpoints)
    arrow (not command arrow, but a 3D arrow model)
    2D shapes in screen space(point, triangle, line, circle)

app.space: Fleet merge commands
	Fleet dtor has to cleanup references to it, tracking should be upon us

app.space: Selection
	app.space: 3D fleet box selection:
		a: local coordinates starting anchor
		b: world space starting anchor
	app.space: 2.5D fleet box selection:
		a: rectangle selection on grid
		b: frustum selection

	TODO P3: Selection Single: Expand / Invert / Subtract to current selection
	TODO P2: Selection 2.5D: Handle cases when the camera is on the z=0 plane and/or the users clicks to +/- inf
	TODO P3: Selection 2.5D: Use hitbox in intersection mode
	TODO P4: Selection 2.5D: Use hitbox in full contain mode
	TODO P3: Selection 2.5D: Variant: Implement both column selection and frustum selection based on the grid coordinates
	TODO P3: Selection 2.5D: Expand / Invert / Subtract to current selection
	TODO P2: Selection 3D: Handle cases where box is drawn in a BL<->TR direction causes no selection
	TODO P2: Selection 3D: Handle case where staring and ending the box on the same frame causes everyone to be selected
	TODO P4: Selection 3D: Variant (Figure out what was the 2 variant, maybe full contain and intersect?)
	TODO P4: Selection 3D: Cleanup a little bit
	TODO P3: Selection 3D: Expand / Invert / Subtract to current selection

	TODO P3: * Expand / Invert / Subtract to current selection means ->
			Box selections should not deselect by default

	TODO P2: libv.ctrl: Upon leave context, (box selection) binary features may want to receive a deactivate call
				| NOTE: This would conflict with binary false in selection, bc this time selection shouldn't commit
					So not tri bool: True, False, Cancel?
				| Thinking about it, starting a box select can be considered as an intent to replace current selection, so global deselect is reasonable


app.space: Selection structure
	- General API over the current selection whatever types those maybe, whatever API client code might need
	- It can go into Simulation / GameState as well as Universe



app.space: Main structure paper ! OUTDATED !

	game instance (desktop) - GameInstance (an object spawned when you launch the application and that remains the same until you close it)
		frame
		controls
		nexus
		settings
		user/player
		ui
		ui main (mp bar, shader overlay)
			renderer(s)
			session (aka old game mode) - GameSession (spawned when a level is loaded)
				[Network base]
				[Network server]
				[Network client]
				gamemode (aka new control concept)
				universe - GameState (spawned by the gameMode)
				playout
				canvas
					& renderers
				ui session (cmd bar)
				ui session mp (mp mini canvas list)

				PlayerController [UI, Controls]
					PlayerState (spawned when a PlayerController is spawned = when a player arrives in the game)

	game.sim:
		- Command based sim state manipulation | Playout
			Types:
			- Control tracking (Camera / Mouse movement, ?Selection)
			- Sim state manipulation (Move, Attack, Production command, ?Selection)
			- Session manipulation (Permission alteration, Kick, Ban, etc)





app.space: Self-Updater

app.space: Frustum visualization

app.space: Camera: Pressing the camera alteration (move/rotate) in one direction for long time (>1-3s) increases speed
app.space: Add multi camera / camera frustum visualization (uniforms and C++ clipping from the main camera, but view from another)

app.space: Optimized VAO update for command arrows (prepare / render step is done, mesh re-upload and glr side should be checked)

app.space: Fleet visualization
	app.space: Render fleet group art
	app.space: Movement, momentum, turning
	app.space: Different fleet shapes (?blockade as shape)
	app.space: Fleet name display (UI Label / Unit plates) 2D<->3D UI layout


app.space: Command arrow improvements
	app.space: Add support for source position offset (Instead of origin use an offset toward the heading direction)
	app.space: Add support for target position offset (Instead of origin use an offset from the incoming direction)
	app.space: Arrow strip placement control from lua (or something lua related) (With auto reload and everything)
	app.space.visual: Command arrow add a glossy holo texture (~simple cloud mixture) to the arrows body (idea come from flowstorm's checkpoint body)
	app.space.visual: Command arrow make the edges less bright to help with AA edge
	app.space.debug: Make the debug command arrow shapes more uniform
	app.space.debug: Make the debug command arrow shapes hooked into the options / settings / config persistent storage

app.space: Line shader (Geometry shader with custom width support) (<1px width = transparency with 1 px width)

app.space: headless server
	To optimize the binary size and skip linking in shit for headless,
	a separate executable needed without any symbol usage of non-headless gamemode


