--- DONE -------------------------------------------------------------------------------------------

libv.glr: Implement shader / program API
libv.glr: Implement Uniform Buffers and Uniform Blocks
libv.glr: Implement UBO layout std140
libv.glr: Generate glsl code for uniform blocks from the C++ code, not the other way around
libv.glr: Uniform<T>
libv.glr: UniformStream
libv.glr: Solve UniformStream batch counting
libv.glr: Texture
libv.gl: cleanup program1/2 shader1/2
libv.gl: cleanup texture1/2
libv.glr: Destroy, Remote ptr, GC
libv.glr: Cleanup mesh API and its includes, split sources as necessary
libv.gl: simplify the functionality, no auto create or destroy, no createData, createLink, plain structs
libv.glr: Texture manipulation, generation
libv.ui: Font2D
libv.ui: String2D
libv.ui: Font cache
libv.ui: Revive UI with minimal set
libv.ui: Label
libv.ui: font loading
libv.ui: context / gl unload que
libv.ui: shader / program unload que
libv.ui: vao / vbo unload que
libv.ui: Render position and render size aka mvp matrix
libv.ui: Rebase ui4 on top of glr
libv.ui: Kill and leftover of ui4
libv.ui.font: font check if bearing is calculated in the font engine
libv.ui.font: Bearing
libv.ui.font: Right side bearing
libv.ui: late attach
libv.ui: selective flag propagation
libv.ui: Program cache
libv.ui: shader / program loading
libv.ui: Revive quad
libv.ui: String2D justify also applies to the last line
libv.ui: Revive image
libv.ui: Solution to the ui context access problem: components should not initiate resource request? Setters should receive the resource type itself
libv.ui: Texture cache
libv.ui: Texture load
libv.ui: Revive stretch
libv.parse: Parse color: source file and pretty API
libv.ui: Parse size
libv.ui.style: properties and minimalistic style, with only static one time read / setup support
libv.ui.style: style-style inheritance, override and composition are the problem of the style definition system and isolated from the properties itself
libv.ui.style: UI component's visualization and behaviour is controlled by properties; Properties are statically typed values; Styles are named dynamic collections of properties; Animations are real time changes of properties
GCC 9.1: Using <filesystem> does not require linking with -lstdc++fs now.
libv.lua: object parser
libv.glr.std140: constexpr static string to pretty name structs
libv.ui: implement float container/layout based on the new container based layout property system
libv.ui: rework panel container to the container based layout property system
libv.ui: rework default layout to the container based layout property system
libv.glr: add viewport feature
libv.ui: make window resize work
libv.ui.style: style safe (parent) storage, replace observer_ref with intrusive_ptr
libv.ui: context ptr in component
libv.ui: attach must be called before create
libv.ui: style auto inherit based on dots
libv.ui: switch foreach children to fill a std::vector<component*>, this vector should be a reusable memory, or (?) just a small_vector<, 32> on the stack | layouts were promoted to containers
libv.ui: integrate style into component and container
libv.ui: auto-read container properties from component's styles
libv.ui: auto-read component properties from component's styles
libv.ui: hard type (enum) align anchor and orient
libv.ui.style: layout properties
libv.ui.style: font properties
libv.ui: use generic_path in context for logging and lookup
libv.ui: None of the module functions should be virtual (?) | they got removed
libv.ui: context_render: move out of module, it is not one
libv.ui: default * property should never be null, provide context access for the property system via archive
libv.ui: manually assigned values to a property shall not be overridden by style (this will be related for animation)
libv.ui: add component exclusive properties
libv.ui: Structure properties and use libv reflection for property sets
libv.ui: unify style and property function that are currently at 3 place (component_base::set/reset/value, propertySet::set, AccessComponent::style) (doStyle can stay, that is a different tale)
libv.ui: setStyle should notify the parent, or signal a flag that its needs to restyled
libv.ui: propagate property set change to actual invalidation of flags
libv.ui: sort out property change auto invalidate flag
libv.ui: releasing a property override should trigger style lookup (reset function) if there is no style, give back the fallback value
libv.ui: sort out flags, invalidation rules and validation traverses
libv.ui: layout strong and week: flags/invalidations
libv.ui: sort out component_base
libv.ui: search and replace layoutPass -> layout
libv.algorithm: Implement a bisect algorithm
libv.range: Implement deinterleave view
libv.ui: make layouts unit testable, its a must given the requirements, traits class for layout related types
libv.ui: grid layout - every element has its own size
libv.ui: port line layout and tests
libv.ui: layouting with content size should not account for nested child non-requested content size: so image(100px, 100px) inside a panel(d,d): here panel should have 100px,100px size (and not the underlying image's size)
libv.ui: port full layout and tests
libv.ui: fix content size bug in full layout
libv.ui: port float layout and tests
libv.ui: fix content size bug in float layout
libv.ui: basic panel base class to handle current panels
libv.ui: remove / removeAll functions for every container
libv.input: New lib to story input enums for frame, ui and hotkey
libv.ui: ContextMouse
libv.ui: MouseWatcher
libv.ui: MouseInterest
libv.ui: MouseEvent
libv.ui: Implement mouse order, for now as a simple depth counter passed along in ContextLayout2 (update the code in button dolayout2)
libv.ui: button
libv.ui: Events are mandatory at this point, implement them
libv.ui: prettify EventMouse to have all the fancy accessors and query subevents
libv.ui: hook up mouse window leave/enter
libv.ui: layout, do not use component internal states as temp variables
libv.ui: sort out lastPosition / lastSize (aka component layout caching)
libv.ui: remove LastSize and LastPosition from component_base
libv.ui.style: Instead of sub/unsub an alternative more safer API would be to traverse every component if any style changed and update components who actually needs it
libv.ui: style should not track components, but restyle everything if style update happens as it should be extremely rare
libv.ui: property should only invalidate if its != to previous value
libv.frame: update glfw
libv.ui: more foreach children usage, MORE and that could solve my Self/Child issue
libv.ui: need doAttachSelf / doAttachChild separation, too easy to fuck-up watching a flag (?)
libv.ui: childID
libv.ui.style: Container child properties are not following style changes
libv.ui.style: Container child properties are not following child's style changes
libv.ui: more of property should only invalidate if its != to previous value
libv.ui: implement component detach
libv.ui: implement component remove
libv.ui: implement layout flag
libv.ui: implement render flag
libv.ui: implement component destroy
libv.ui: implement top level ui detach on exit
libv.ui: implement top level ui destroy on exit
libv.ui: Hide component internals
libv.ui: kill every immediate importance task and make a proper commit
libv.ui.style: account for event based style changing or state based style declaration
libv.ui.style: style and property update | might be optional, or the animation system itself used for it | fullscan approch was implemented
libv.ui.style: style could store each component using them making invalidation possible, would listen to attach/detach | fullscan
libv.ui: implement detach and component removal
libv.ui: wire in component create and destroy
libv.ui: String2D would be nice to have both last line and non last line justify
libv.ui: Label text change layout invalidation (lazy?) | verify
wish: rename LIBV_REQUIRES to WISH_REQUIRES | (?)
wish: rename GIT_BRANCH and ..HASH to WISH_GIT_BRANCH and ..HASH | only the C++ macros, the cmake vars are correct
libv.ui: rename ComponentBase to BaseComponent or even to Component (?) | (Component or BasicComponent might end up being a CRTP class)
libv.log: rename libv::logger to libv::logger_stream
libv.ui: rename size's "content" to "dynamic"
libv.meta: rename n_times.hpp to for_constexpr
libv.meta: rename if_void to lnv (as leftmost-non-void) and make it variadic
libv.utility: rename approxing.hpp to approx.hpp and the class name too
libv.frame: rename onContextInitialization, onContextRefresh, onContextTerminate to Create Update/Render Destroy
libv.utility: move Slice from utility to algorithm
libv.frame: update glfw
libv.frame.glfw.frame: Deprecated charmods callback
libv.frame: serialize events
libv.frame: Merge mouse position events (only if there was no intermediate event)
libv.frame.glfw.core: Deprecated window parameter of clipboard string functions
libv.frame.glfw.frame: Added glfwFocusWindow for giving windows input focus
libv.frame.glfw.frame: Added glfwRequestWindowAttention function for requesting attention from the user
libv.frame.glfw.frame: Added glfwGetWindowFrameSize for retrieving the size of the frame around the client area of a window
libv.frame.glfw.frame: Added glfwMaximizeWindow for window maximization
libv.frame.glfw.frame: Added glfwSetWindowMaximizeCallback and GLFWwindowmaximizefun for receiving window maximization events (#778)
libv.frame.glfw.hint: Added GLFW_MAXIMIZED for window maximization
libv.frame.glfw.frame: Added glfwSetWindowSizeLimits for setting absolute window size limits
libv.frame.glfw.frame: Added glfwSetWindowAspectRatio for setting relative window size limits
libv.frame.glfw.core: Added glfwSetWindowAttrib function for changing window attributes (#537)
libv.frame.glfw.frame: glfwSetWindowAttrib supports GLFW_DECORATED for existing windows
libv.frame.glfw.frame: glfwSetWindowAttrib supports GLFW_RESIZABLE for existing windows
libv.frame: remove unnecessary atomics
libv.frame: replace fix state arrays with flat_maps
libv.frame: Implement floating aka always on top
libv.frame.glfw.frame: glfwSetWindowAttrib supports GLFW_FLOATING for existing windows
libv.frame.glfw.hint: Added GLFW_FLOATING for creating always-on-top windowed mode windows
libv.frame.glfw.hint: Added GLFW_FOCUSED window hint for controlling initial input focus
libv.frame.glfw.hint: Added GLFW_FOCUS_ON_SHOW window hint and attribute to control input focus on calling show window (#1189)
libv.frame.glfw.hint: Added GLFW_LOCK_KEY_MODS input mode and GLFW_MOD_*_LOCK mod bits (#946)
libv.frame.glfw.frame: glfwSetWindowAttrib supports GLFW_FOCUS_ON_SHOW for existing windows
libv.frame: CursorMode and glfwSetInputMode
libv.frame: glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
libv.frame: glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
libv.frame: glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
libv.frame: fix clipboard thread
libv.frame.glfw.frame: Added glfwSetWindowIcon for setting the icon of a window
libv.frame: icon support, glfwSetWindowIcon(window, 2, images);, Preferred in 3 resolutions are: 16x16, 32x32, 48x48, (maybe as an extra 24x24, 64x64)
libv.frame.glfw.monitor: Added glfwGetMonitorPos, glfwGetMonitorPhysicalSize and glfwGetMonitorName for retrieving monitor properties
libv.frame.glfw.monitor: Added glfwGetMonitorWorkarea function for retrieving the monitor work area (#920,#989,#1322)
libv.frame.glfw.monitor: Added glfwGetMonitorContentScale
libv.frame.glfw.frame: Added glfwSetWindowMonitor for switching between windowed and full screen modes and updating the monitor and desired video mode of full screen windows
libv.frame: DISPLAY_MODE_BORDERLESS is not perfect, fix it | DisplayMode change itself has some issues
libv.frame: implement setDisplayMode without cmdFrameRecreate
libv.frame: bug: hide then restore breaks something (the redraw?), repeated show fixes it | invalid events caused the issue, now they are discarded with workaround
libv.frame.glfw.frame: Added glfwGetWindowContentScale and glfwSetWindowContentScaleCallback for DPI-aware rendering
libv.frame: cleanup core and core proxy
libv.frame: add a mutex to event callbacks and event queue
libv.frame: add a mutex to windowHandlers
libv.frame: add a mutex to monitors map
libv.frame: add a mutex to frame (its needs one because of the getters could access data members)
libv.frame: Review threading and ownership models of the whole library | I just throw a bunch of mutex at the problem, I feel guilt
libv.frame: cleanup includes
libv.ui: use the following pattern for unnamed components: struct adopt_lock_t {}; static constexpr adopt_lock_t adopt_lock;
libv.ui: focus - Two main operation: focus-traversal (finding the next focus target) and focus-change (event of focus change to the component selected by focus-traversal)
libv.ui.focus: Focusable is new optional property (not the property system) and FocusableSelf / FocusableChild are new flags for it
libv.ui.focus: Focus traversal order: component hierarchy
libv.ui.focus: Focus-traversal with precise direction instead of just the 2/4/8 base direction (1 float is enough for angle)
libv.ui.focus: UI should have a pointer to the currently focused object
libv.ui.focus: Focus-change event
libv.ui.focus: Focusable Components should store a flag if its focused (this also helps with detach)
libv.ui.focus: Focus-traversal operation triggers a Focus-change event on both end
libv.ui.focus: Direct focus can be triggered by code
libv.ui.focus: Mouse events can trigger direct focus | non-automated version
libv.ui: key input
libv.ui: char input
libv.ui.component: input field
libv.ui.keyboard: keyboard event are forwarded directly to the focused object and traversed up the focus stack until intercepted
libv.ui: Implement / check on detach
libv.ui: Implement / check on destroy
libv.ui: remove layout2 pass member variables in component_base
libv.ui: Question: does style change means property update? | this could be a rare enough event to brute force the whole ui style refresh, but only if its not event driven | style does not change, style change is only supported for debug/development
libv.ui.event: add a component based mouse event (virtual function) option BESIDE the current watcher one
libv.ui: automate MouseRegion update, request a component to be passed alongside the watcher, set a flag, if flag set, auto update in layout2 | only works if mouse region matches the component position and size, or if it does a separate pass | added a component based watcher BESIDE the current watcher one
libv.ui: consolidate MouseInterest flags
libv.ui: flags set in ctor -> parent might not get the relevant *child flags, check on propagation (self/child masks)
libv.ui: component detach does not remove certain flags from parent, parent have to rescan child to determine correct flags
libv.ui: with capability oriented flags, the flags.reset should prompt reevaluation of flags in the parent ('set' part is taken care by flagAuto) | its already taken care by the top-down passes of the capabilities
libv.ui: event oriented flags, reset should unsub from events | solved by separate set/get and flagPurge
libv.ui: event oriented flags, set should sub for events | solved by separate set/get and flagPurge
libv.ui: focus, key and char watcher and dynamic change of them
libv.ui: pimpl ContextUI
libv.ui: style should be forward declared
libv.ui: Input field have/display cursor
libv.ui: direct access font texture | i think this will also improve texture bind codes, making them more uniform
libv.ui: Position InputField cursor correctly
libv.ui: Stream2D move back to utf8
libv.ui: Stream2D merge back to String2D
libv.ui: Shelf Stream2D as StringU2D
libv.ui: String2D API get position of character between space, by index: 0 = before first char, 1 = before second char, size() and size()+k = after last character
libv.ui: ui.settings and its FAST availability from context() | settings might end up being really stored in the context
libv.ui.property: remove style code from base_component.hpp (ContextStyle) (optional / best effort)
libv.ui.property: free property name binding
libv.ui.property: need support for structure and different names, libv.reflection might gets a hit because of this
libv.ui.property: remove fallback from properties and place it into context_ui as a fallback style
libv.ui.property: detect to property changes
libv.ui.property: react to property changes
libv.ui.property: property set / get via functions to eliminate mandated property storage in component
libv.ui.property: set/get/reset changed/manual in general not only in hybrid
libv.ui.property: setter / getter issue: does not set manual/changed flag when called manually
libv.ui.property: have a single line in set/get function that refers to the property?
libv.ui.property: hybrid reflection - static
libv.ui.property: hybrid implement doStyle work
libv.ui.property: hybrid Add a default / init value per instance ("above" fallback)
libv.ui.property: hybrid reset (address could be used to lookup) | simple full style invalidation at first
libv.ui: rename cursor to caret
libv.ui.property: migrate to hybrid reflection
libv.ui.property: cleanup old non hybrid property codes: PropertyFF, valueFF
libv.ui.style: cleanup fallback style
libv.ui: setX() / getX() -> void X(T) / T X()
libv.ui: mark every component type one paramed ctors as explicit (and maybe check on every ui class too)
libv.ui.font: line 179 not just log but return default on error
libv.ui: using FontSize = int16_t; -> enum class FontSize : int16_t {};
libv.ui: flatten - flatten EventMouse to combat variant complexity
libv.ui: signal-slot and event proxies, do not store a signal inside the component, use a member function event() to yield a proxy that has many signals | Couple of changes, global ContextEvent dispatcher, no proxy
libv.ui: contextlessness
libv.ui: events for input field
libv.ui: rename UnnamedTag_t to GenerateName_t
libv.ui: events for button
ext: adopt https://github.com/dacap/clip
libv.ui: clipboard access from ContextUI
libv.ui.input_field: paste support
libv.ui.input_field: copy support
libv.ui.input_field: caret support
libv.ui: Is text is a component property that cannot be set from style, BUT it can be accessed dynamically in a uniform manner? | do I really have to implement a 'property' method ? | Yep, implemented as synthesize property
libv.ui: String2D fix for new line (glyphless) mean no entry in the mesh for it | solved by hidden glyphs
libv.ui: String2D fix new line before after glyph is not possible if there is no glyph in the line | solved by hidden glyphs
libv.ui: String2D fix new line before after glyph bearing issue (test char '[') | solved by hidden glyphs
libv.ui: String2D new line alignment tests
libv.ui: Verify if String2D is pen.x += kerning.x; to early | it is not, it helps with correct line width
libv.ui: String2D fix new line alignment
libv.ui: String2D fix justify cursor placement | space glyph should be snapped to the left and not to the right
libv.ui.input_field: test cursor placement with a non mono font
libv.ui.input_field: cut support
libv.ui: fix cut-paste breaks search field (? with newline involved)
libv.ui: add exception catch beds to main ui operations
libv: fix build for all / tests / run tests
libv.ui: String2D set/get modernization
libv.ui: Every event: focus, mouse, key, char shall provide access to the entire state universe | Access to state universe from everywhere
libv.ui: Make focus nullable
libv.ui: Remove context_state.focus_ handling from ImplUI, remove ImplUI from ContextState
libv.ui.input_field: caret mouse support
libv.ui: String2D getClosestCharacterIndex should use pen position, some glyphs are all over the place
libv.ui.input_field: synthesize caret property
libv.ui.input_field: mouse caret placement respect line
libv.ui.input_field: fix that lines tend to snap down | Solved by determining that LineAdvance != LineHeight
libv.ui: String2D API to find nearest character position
libv.gl: framebuffer
libv.gl: Texture2DMultisample
libv.gl: Texture2DMultisampleArray
libv.gl: blit
libv.gl: renderbuffer
libv.gl: multisample capability
libv.gl: glReadPixels
libv.gl: rename framebuffer read|draw*D function family to attach_read|draw*D and add plain attach
libv.glr: framebuffer
libv.glr: framebuffer binding
libv.gl: ability to current bound texture
libv.glr: solution for internal hiding but exposing correct offset for inline "direct" access to mandatory info (id and dirty) | aliasing head
libv.glr: framebuffer auto init textures | solved with sync_no_bind()
libv.glr: optimize textures with head access
libv.glr: texture_fwd.hpp
libv.glr: RemoteTexture should have its own header file
libv.glr: renderbuffer
libv.glr: blit
libv.gl: track framebuffer bindings and eliminate duplicate bind
libv.glr: Texture2DMultisample | RemoteTexture will be the most work, might worth to think about a different type?
libv.glr: Texture2DMultisampleArray
libv.glr: multisample capability
libv.glr: glReadPixels | only makes sense in remote, and not for queue
libv.glr: rename gc to DestroyQueue
libv.glr: first half of a major overhaul on includes and code structure | hide remotes, provide head access
libv.glr: cleanup queue
libv.ui: debug zoom in overlay
libv.ui: component level overlay system
libv.ui: component fix attach-detach
libv.ui: debug zoom proper frame buffer size setup | based on component level layout
libv.ui: debug zoom toward center
libv.ui: mouse grab system, a way to soft mutex mouse event positions to an initiator mouse watcher
libv.ui: bug: mouse acquire might generate extra events? | null update was broadcasted on accident
libv.ui: scroll bar (aka slider) without the scroll pane
libv.ui: remap mouse input in debug zoom mode (remap function) | inline remap causes hazard on movement | fixed by control/view split but rounding might broke things
libv.ui: overlay zoom, zoom toward mouse
app.vm4_viewer: list models
app.vm4_viewer: load model
libv.vm4: Generate flipped winding order version of index sequences for mesh inside inverted nodes
app.vm4_viewer: show model wireframe (gl fill mode based)
libv.vm4: fix vm4 root node issue
app.vm4_viewer: show model fragment input values
app.vm4_viewer: Implement camera
app.vm4_viewer: Implement camera controls
libv.vm4: Import calculate AABB
libv.vm4: Import calculate BS
app.vm4_viewer: Visualize AABB
app.vm4_viewer: Visualize BS
app.vm4_viewer: Reset camera on model loading
app.vm4_viewer: Camera center and focus model (without altering the rotation)
app.vm4_viewer: Reset camera / Focus camera
app.vm4_viewer: Visualize grid-XY
libv.fsw: Lib to wrap a file system watcher
libv.fsw: improve file watcher to handle single file and multi callbacks
libv.fsw: use absolute path internally, pass rel or abs path to the callback based on the sub
libv.fsw: guard redundant watchers and ownerships
libv.fsw: subscribe_directory
libv.fsw: WA0001 workaround
libv.fsw: unsubscribe (with cleanup)
libv.fsw: Remove WA0001 workaround
libv.ui: instead of return value use (with different name) void stop_propagation() const; / bool propagation_stopped() const; / mutable bool stop_propagation_{ false };
libv.ui: Mouse events should respect stop_propagation
libv.ui: Mouse event absorb/shield/plates
libv.ui: alias any libv.input event in libv.ui for consistent access
app.vm4_viewer: proper camera grab
libv.ui: Rename mouse_table to context_mouse
libv.gl: Implement a GLSL engine
libv.gl.glsl: Implement primitive preprocessor with #include and include dirs
libv.gl.glsl: Warning option for crlf line ending.
libv.gl.glsl: Warning option for space indentation or if indentation characters are mixed
app.vm4_viewer: single directional light
app.vm4_viewer: show model grey lighted (phong)
app.vm4_viewer: single point light
app.vm4_viewer: single spot light
libv.glr: general function callback and remote bypass / callback with gl state
app.vm4_viewer: shader manager bypass libv.glr to access libv.gl
libv.glr: program adopt and swap with libv.gl
app.vm4_viewer: shader include base directory
app.vm4_viewer: shader loader
app.vm4_viewer: do not change shader if shader load/compile/link failed
app.vm4_viewer: throw out old shader code, rename shader2 to shader
app.vm4_viewer: shader should sub for every included file
app.vm4_viewer: shader should unsub from file watcher, ATM there is an issue during program termination
app.vm4_viewer: solve 3 line of error while program reloading happens
app.vm4_viewer: cleanup cpp shader codes
app.vm4_viewer: ui feedback for glsl shader error, big red text
libv.hotkey: Rename to libv.control
libv.control: design API | multiple sub-system: normalization, routing, binding, conversion, action, context, presentation
libv.control: context template static cast void* trick to set new context payload
libv.control.sandbox: start a sandbox, compile a null operation
libv.control.sandbox: compile/implement/run API front of feature_action
libv.control.sandbox: compile/implement/run API front of feature_binary
libv.control.sandbox: compile/implement/run API front of feature_analog
libv.control: auto promote input to combination on demand in every context (preferably with overloads)
libv.control: auto promote input to sequence on demand in every context (preferably with overloads)
libv.control: auto promote combination to sequence on demand in every context (preferably with overloads)
libv.control.sandbox: compile/implement/run API front of binding
libv.control.sandbox: compile/implement/run API front of keycode/scancode input
libv.control: Build internal SOW from input events
libv.control.sandbox: compile/implement/run API front of update
libv.control: InputID as_enum member function helpers, renaming of members getters
libv.control: to_string for InputID
libv.control: to_string for InputID enum members
libv.control: change "--invalid--" to "<<invalid>>" and "<?>"
libv.control: Move InputID tests to a test format
libv.control: Improve InputID parse to handle mouse half dimension
libv.control: Parsing joystick analog
libv.control: Parsing joystick button
libv.control: InputID Gamepad
libv.control: Explicit Gamepad support
libv.control: Gamepad support (except SOW)
libv.control: Gamepad any support
libv.control: Joystick any support
libv.control: Parsing gamepad analog
libv.input: Move Keycode parsing tests to libv.control and remove key parsing from libv.input
libv.control: Gamepad SOW support
libv.control: rename parse_input_sequence files
libv.control: AnalogInputAction is not present in Input | invalid as it is present in inputID
libv.control.parse: Active tests for keycode parsing
libv.control: InputID alias matcher
libv.control: InputID alias matcher tests
libv.control: Routing: Every DIA x button
libv.control: Routing: Every DIA x time
libv.control: Routing: add binding states
libv.control: design normalization layer
libv.control: design routing layer
libv.control: design binding and conversion layer
libv.control: design context layer
libv.control: design feature layer
libv.control: Routing: maintain binding states
libv.control: Routing combination of buttons
libv.control.parse: Parsing gamepad button
libv.control.parse: Test parsing invalid gamepad analog
libv.control.parse: Test parsing invalid gamepad button
libv.control: Routing issue: sequence checkpoint is uselessly too weak, "Ctrl+A, A" the first "A" release resets the checkpoint on the second step | solved by only reseting sequence from the last step
libv.control: Button input processing
libv.control: design presentation layer
libv.control.parse: Input parsing
libv.control.parse: Combination parsing
libv.control.parse: Sequence parsing
libv.control: Function to verify sequence rules
libv.control.parse: Combination timeout parser | OR cut out combination timeout | choose latter | Invalidated
libv.control: cut out combination timeout, make a global sequence timeout
libv.control: Only Control level  sequence timeout, no per combination
libv.control: libv/control/input.hpp is wrong name, it should be enum or someting like event enums, and Input class should have this header
libv.control: implement rest of bind functions, call to parser
libv.input: Add support for joysticks and game-pads
libv.control: Sequence normalization
libv.control: Sequence alias normalization
libv.control: List binding fail conditions
libv.control: Report binding errors, and fail if needed
libv.control: Implement Controls::bind outcomes
libv.control: Controls::bind and feature functions are not using ctors
libv.control: Routing: Analog input processing
libv.control: Routing: Time input processing
libv.control: Routing: feature gather, and broadcast in step 2
libv.control: Implement codepoint mapping
libv.control: Routing: scancode
libv.control: Routing: codepoint
libv.control: Control level sequence timeout settings
libv.control: Idea: sequence could mandate by rule to not have any funny dia for non last, hmmm, it should, even if I dont utalize this while coding... its really should. | verify does this, but verify is not yet really used
libv.control: Idea: move dia from input to combination | what would it solve? | nothing, invalidated
libv.control: AIA inside input ID is not a proper fit (!) blocking Analog input processing | I might be able to just ignore this one by two parameter | ignored with two parameter
libv.control: scale and impulse settings for each input source (and for global)
libv.control: Determine the correct scales, how each scale-er effect the final value (for simple and sequence case)
libv.control: mouse is not diff but position based atm I think
libv.control: mouse px is bad, use value normalized to shortest window dimension | both are needed: cannot change mouse sensitivity based on window or interactive area size without concent | mouse device px speed is the best solution | mouse px is ok if scaled
libv.control: mouse hardcoded scale
libv.control: Bind could use str instead of str_view, same goes for feature
libv.control: cleanup or remove input_table.cpp/hpp and input_id.cpp | input_id.cpp stays
libv.control: "2x4" to_string for sequence and combination | only name and symbol
libv.control: Query if a binding has actually feature behind it
libv.control: Feature register proxy
libv.control: Feature register, a limited API view that only allows registering features
libv.control: Feature auto-register solution to client global
libv.control: Auto feature register, without the backed in global variable into the lib
libv.control: Feature hash storage
libv.control: Sequence builder | invalidated
libv.control: Implement codepoint mapping observation
libv.control: What is the format for IO? Json? Lua? XML? Text? | Some very rigid text for now
libv.control: A way to quickly save and load bindings, aka binding serialization | Very plain text, bit painful
libv.control: Design persistence layer
libv.control: A way to quickly save and load settings: impulse, scale and timeout
libv.control.parse: Automated test for every input_id: symbol, identifier and name to be parsable | not automated, but a decent test, automation would have not saved much time
ext.x3: detect end of input, control and other parsers could benefit | x3::eoi
libv.control.parse: Mouse scroll without dimension should default to Y, update symbol table and parser
libv.control.parse: Mouse scroll should not require word_mouse | only if long names or mouse word are used so its not ambiguous
libv.control.parse: InputID scroll parsing
libv.control.parse: InputID parsing
libv.control: reorganize files
libv.control: Remove unused/commented codes
libv.control: Cleanup first lines in every source file
libv.control: Routing: Implement deadkey set single decision point
libv.control: Routing: Sequences dead-key like behaviour
libv.control: Routing: Idea: sequence can only progress to the next step if the current step is fully dissatisfied (maybe with the only exception to modifier keys, or a special flaggy thingy handwavey thing around dia); This would be the Netbeans way, but that does not allows holding down the modifiers and pressing keys and clion allows that | The Clion way is better
libv.control: Routing: Time timeout sequences
libv.control: Implement unbinding
libv.control: Cleanup binding_outcome and unbinding_outcome
libv.control: Binding storage (and active_bindings ptr stability)
libv.control: Routing: Select bindings based on more specialized
libv.control: Routing
libv.control: Scale in analog member, they should be scale / time / impulse, and i should use them
libv.control: Routing: record scale for entering active bindings | invalidated: killed button scales
libv.control: Determine the correct scales for multi type combinations | invalidated: killed button scales
libv.control: Scale implemented up to process functions, implement inside process and think about fullfilled binding
libv.control: List (into the paper) what is: global/per source/per binding/per feature setting
libv.control: Configuration and settings
libv.control: Remove debug trace messages, CONTROL_DEBUG, iostream, etc...
libv.control: 2 (+ 1) Example sandbox to presented in the paper
libv.control: Rename libv.control to libv.ctrl
libv.ctrl: Would be nice to merge keycode-codepoint-scancode events to a single pass | Its must due to sequence cancellation
libv.input: rename EventKey::key to EventKey::keycode
libv.ui: event two param, one for the component one for the event
libv.ui: Use an intrusive ptr like pattern for component internal storage
libv.ui: Common base class for event "host stubs" to handle general events (mouse / keyboard / component lifetime)
libv.ui: Provide general events for every component
libv.ui: Hide component parent management | thread local variable to hide UI* context in it
libv.ui: Idea move "real" component creation to attach time, removes the ctor ctx overhead | Cancelled
libv.ui: sandbox has some off colors that should not happen | the res white image was dirty
libv.ui: Hide component memory management: sp<Label> -> Label = magic<ImplLabel>
libv.ui: component base fire should reject non this pointer or types
libv.ui: Clean up base_component/component includes with the new memory model
libv.ui: Remove every usage of std::shared_ptr<BaseComponent>
libv.ui: Fix typo: Travers -> Traverse
libv.ui: Autonaming should use per type indexing
libv.ui: align_vertical for string2D
libv.ui: align_vertical for string2D in pickers | Well, the algo was fool proof and it just works
libv.ui: container child anchor_parent, anchor_target and size are general concept and every component should have them -> eliminates child storage issues (for now) AND grid anchor_content is also here
libv.ui: property size / anchor
libv.ui.layout: anchor should be a general property, when a component placed somewhere beside unused space single enum which of the 9 corner should it use
libv.ui.property: layout properties: size / anchors (+padding) (+?merge cells) | can size + anchor be generalized? | yes and padding too
libv.ui: layout_line should support anchor | invalidated as the two alignment basically already solves the use-cases
libv.ui: property size / anchor access, and inherited property access | manual, it will do but for now
libv.ui: Rename BaseComponent to CoreComponent
libv.ui: Remove mask_watchMouse in favor of a single bool flag as mouse movement determines the other event targets
libv.ui: Improve layout pass 1 information channel: doLayout1 should use the return channel instead of member cache
libv.ui: broken layout with String2D with size = "100px, d" if text is longer than 100px, layout1 issue | main reason is that layout1 pass uses no limits (in string_2D)
libv.ui: implement parentDependOnLayout, reduce the number of layout invalidation caused by String2D edit
libv.ui.style: parent depends on layout invalidation could be introduced into the property as function test just like fallback | size is now a property and it maintains the parentDependOnLayout flag
libv.ui: text layout: rework string2D to not use GLR, it should be just a plain layouter, prep data into local buffer and provide span getters? | an alternative text layout was introduced
libv.glr: Implement sub-mesh API | it was kind of already usable as base_vertex, base_index and num_indices
libv.glr: Texture and Program base_ref
ext.x3: debug build x3 parser in libv.ctrl fails with an assert | the cause were the ascii skipper failing, switched to unicode skipper
libv.ui: Add local_mouse to the ui info uniform block | how to preserv the data | use mvp transforms instead
libv.ui: Rework mouse context internals
libv.ui: Rework render context internals
libv.ui: Rework layout context internals
libv.ui: rework render
libv.ui: component color go from uniform to vertex attribute
libv.ui: move render iteration into the containers (to allow render state manipulation and clipping (?))
libv.ui: Implement basic scroll area
libv: Merge include and src folders
libv.ui: Auto set mvp matricies for the UI shaders | (?) | might not be possible | UI renderer took care of it
libv: Update every file first lines
libv.math: Assume T to be trivial and well behaving in vec and cleanup or update: decltype(auto) -> auto or T*, length[SQ] : T, , nodiscard, noexcept, etc...
libv.math: Remove vec dependency to glm, concepts should be able to handle it, if it must, or create bridge
libv.math.vec: inf, -inf, nan, -nan, zero: vector creator functions
libv.math: Add/verify structured binding support for vec_t | works for 2, 3, 4, not for the rest
libv.math.vec: Implement operator% | for floating point types it calls fmod
libv.math: Make every vec / mat operator a hidden friend | Is it possible or is it worth it (it might make 5 overload from the current 3 per operator)? | Moved everything that was worth it
libv.math: Create vec_fwd and mat_fwd headers
libv.utility: opt_ref<T> and opt_ref_none to alias T* | reworked optional_ref<T> to the same idea
libv.ui: update every component to the new renderer | (overlay_zoom uses glr, but its fine)
app.gen_ui_theme: App to generate and modify UI themes
app.gen_ui_theme: modernize to use libv.frame
libv.gl: more glewInit into GL
libv.ui: store glr remote inside UI, which is reasonable, might need some alteration
libv: Fix build errors and warnings (except vm4_viewer)
app.gen_ui_theme: modernize to use libv.ui
libv.ui: Implement CanvasAdaptor component
app.gen_ui_theme: move blend/effect implementations to C++
app.gen_ui_theme: enable multithreading
app.gen_ui_theme: split canvas/engine/effect related codes
libv.thread: work_cooldown add delay too not just cooldown
app.gen_ui_theme: move effect definition list to lua
app.gen_ui_theme: implement multiple generation tasks support
libv.ui: Implement thread switch support for UI modifying tasks
app.fsw: New file system watcher app (lifted from iris)
libv.fsw: Rename watcher file to file_watcher, or the class the other way around | class rename preferred
app.gen_ui_theme: Reduce the number of thread swapping during reloading
app.gen_ui_theme: Keep worker threads alive between runs
app.gen_ui_theme: Rename to app.theme
libv.thread: Rename to libv.mt
app.theme: add lua <-> C++ linked ui elements for float selection
libv.img: New library to handle image saving
libv.ui: verify: check if mark remove should be recursive | it is, markRemove does it perfectly
libv.ui: remove layout flag | invalidated: used to exclude components that are marked for removal from the current loop
app.theme: Improve SOW management
app.theme: Solve the event loop problem | in place, not really generalized
app.theme: box shape | solved with rounded box with corner = 0
libv.net.mtcp: Cleanup source file and pimpl patterns
app.update: Start update server implementation
libv.net: Switch back to boost asio
ext: Remove unused netts
libv.net: Make connections transfer rate limitable: https://www.boost.org/doc/libs/1_74_0/libs/beast/doc/html/beast/using_io/rate_limiting.html
libv.net: Statistics: Byte sent, byte received total, Messages sent, messages received, ?connection time
libv.net.mtcp: On error extra parameter enum to indicate the source operation of the error
libv.net: Wrap IOContext accessor in fwd
libv.net: Move rate_policy into its own header
libv.net: Make connections movable | it was already movable, but now its explicit
app.update: Connection dtor calls in vector resize | Session memory address is leaked to callback, so address stability is required, solved with unique pointers
app.update: Proper disconnect, Cleanup lost connections (sessions)
libv.utility: Add parse number utility functions
libv.net.mtcp: Add endpoint selection support for acceptor
libv.net: Implement perfect connection teardown
libv: Split main track development to 3: Updater, UI, Game
libv.diff: New library for diff and patch management
libv.diff: Implement in memory diff and patch support
libv.diff: make sure every stream of lvalue ref output respects offset
ext: adopt colony https://github.com/mattreecebentley/plf_colony
libv.frame: Use glfwSetWindowUserPointer glfwGetWindowUserPointer
app.enum: new enum gen | rename and refactor
app.enum: Add unary operator+ as an alias for to underlying
libv: Adopt the new type_key in every map that uses types as a key
build.ninja: some ext target fails, otherwise it should be clear
build.ninja: (Ninja only) Make all external job part of a JOB_POOLS with 3 running at max | Cancelled: ExternalProject_Add has no support for JOB_POOL
libv.sys: New library for OS related tools
libv.sys: Open links/files with the OS defaults: https://stackoverflow.com/a/60225910
libv.sys: Move clipboard text to it from libv.ui.context_ui
libv.sys: Clipboard text (light wrapper above clip:: + deal with windows line ending)
libv: Rebase every branch to a recent commit
libv: Change /*implicit*/ comments to explicit(false)
libv: Upgrade to GCC 11.2 and C++23
libv: Default operator== where applicable
wish: file glob CONFIGURE_DEPENDS https://cmake.org/cmake/help/v3.14/command/file.html#command:file
wish: use ProcessorCount instead of system call
ext: Acquire a crypto lib
ext: Acquire a hashing lib (the MD5 will not be enough forever)
libv: Move from std::holds_alternative to std::get_if
libv.glr: UniformBlockSharedView_std140






--- STACK ------------------------------------------------------------------------------------------












What do I need from libv to make a 'minimal' working iris program?
	libv.ui
		2 List component
		3 Scroll pane = scroll area + scroll bar + connecting them
		5 Font outline render
			freetype2 Now has an SDF render option
			spread property set:
				const FT_Int spread = 8;
				FT_Property_Set(library, "sdf", "spread", &spread);
				8bit uint normalized to [+spread .. -spread]
			(There is also a newly found lib: https://github.com/Chlumsky/msdfgen and https://github.com/Chlumsky/msdf-atlas-gen)

	libv.ctrl
		4 Interaction with UI
		5 Resolve analog-binary accidental collusion with time

	libv.serial
		3 Safe container resize/reserve on deserialization

	libv.update
		Resource
			1 Working resource download protocol
			1 Update/Resource signature verification
		Working update
			1 Self update support
			1 Marry Resource and Update
		Deployment
			2 Scripts to create a new build and deploy to libv.update servers

	libv.state
		5 Generated source for state machines




ext: lexy https://github.com/foonathan/lexy
		try out / adopt
		Parser lib
		https://www.youtube.com/watch?v=Cb0j6DVmwzY


ext: adopt https://github.com/olegpublicprofile/stdfwd
ext: Light SQL database engine, maybe useful for updating: https://github.com/azadkuh/sqlite-amalgamation

libv: Make sure that ALL usage of fs::path's .string() uses UTF8: std::filesystem::path::u8string and std::filesystem::path::generic_u8string
		Search for .string(), not that many
		Search for generic_string(), not that many
		also, review/kill .string usages (?)

libv: Remove friend class X; and use friend X; and ensure that X is fwd declared in the proper scope

C++20
	Look into: <syncstream> https://en.cppreference.com/w/cpp/io/basic_syncbuf
	Check on: Calendar additions to <chrono>
	Atomic wait and notify operations.
	<barrier>, <latch>, and <semaphore>

	Immediate functions (consteval)
	Standard library header units


This looks like a useful concepts:
	concept non_cv = std::same_as<D, std::remove_cv_t<D>>
	concept non_cvref = std::same_as<D, std::remove_cvref_t<D>>



libv.sys: Keep awake
		WIN: Repeated call to:
			Header 	winbase.h (include Windows.h)
			// The following sets the appropriate flags to prevent system to go into sleep mode.
			SetThreadExecutionState(ES_CONTINUOUS | ES_AWAYMODE_REQUIRED | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED);
			// This clears the flags and allows the system to sleep normally.
			SetThreadExecutionState(ES_CONTINUOUS);
			DOCS:
				https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate?redirectedfrom=MSDN
				ES_CONTINUOUS informs the system that the state being set should remain in effect until the next call that uses ES_CONTINUOUS and one of the other state flags is cleared.
				ES_AWAYMODE_REQUIRED forces media applications to run in the background, so that you can call your application by voice.
				ES_SYSTEM_REQUIRED Forces the system to be in the working state by resetting the system idle timer.
				ES_DISPLAY_REQUIRED Forces the display to be on by resetting the display idle timer.
		UNIX:
			?

libv.res: Resource - New library for resource and asset loading, caching and tracking
		Based on the libv.rev's Shader and ShaderLoad the same concept can be generalized for
		assets, audio, textures, mods/scripts and models

		Requirements:
			cache
			load and inclusion/extension of tracking set (recursion should be possible)
			filesystem resources
			filesystem resource fragments (inclusion subjects)
			virtual resources
			virtual generated resources
			tracking of virtual resources
			tracking of filesystem resources
			load/reload/unload/tracking events
			excellent compile time: runtime polymorphism or easy pimpl (2 hook class, 1 manager, 1 resource that are type erased)

app.editor:
	small app for first line and include order fix-ups
	use the folder .editor in the project root are store
		.editor/first_line.txt
		.editor/include_order.txt | or .lua?
			special_line_like_hpp
			[if condition] line
			// line
			regex.*.hpp
			line
			[line if next section is not empty?] line
			wildcard.**.hpp
			| Sorting order: folders first
		| validate that no lpp file (local header file) is included from a hpp file
		| validate pragma once is used and only used in lpp or hpp files
		| warning on [cpp,c,cxx,...] aka source extension include


ext: Edit Distance https://github.com/erikerlandson/edit_distance

place.it: flat_varfix_map (would be usable for style.properties)
	template <typename Key, typename Value>
	struct flat_varfix_map {
		std::byte* data;

		explicit flat_varfix_map(size_t num_value) {
			const auto padding = alignof(Key) > alignof(Value) ? 0 : alignof(Value) - alignof(Key);
			const auto mem_size = sizeof(Key) + padding + sizeof(Value) * num_value;

			data = new std::byte[mem_size];
		}
		ctor
		cctor
		cassign
		mctor
		massign
		~flat_varfix_map() {
			...
		}
	};

place.it:
	tool.profiler: https://github.com/bombomby/optick - But it doesnt support OpenGL
	tool.profiler: https://github.com/wolfpld/tracy
	tool.audio: https://non.tuxfamily.org/

	cpp.tool: build-bench.com - Benchmark compile time
	cpp.tool: godbolt.org - Test build and analyze compiler asm
	cpp.tool: quick-bench.com - Mirco benchmark runtime
	cpp.tool: perfbench.com - Mirco benchmark runtime with more detail
	cpp.tool: cppinsights.io
	opengl.knowledge: docs.gl - Reference documentations
	opengl.knowledge: learnopengl.com - Great tutorial site
	opengl.knowledge: ogldev.org - Great tutorial site
	opengl.knowledge: open.gl - Great tutorial site
	opengl.knowledge: opengl-tutorial.org - Great tutorial site
	opengl.tool: renderdoc.org - Renderdoc
	regex.tool: regex101.com
	regex.tool: regexr.com

	reference.ui: Amazing Game UI reference page: gameuidatabase.com

	cpp.chrono: zoned_now = std::chrono::zoned_time(std::chrono::current_zone(), std::chrono::system_clock::now());
	cpp.modules: A solid read: https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/
	cpp.modules: g++ -fmodules-ts -std=c++20 -c -x c++-system-header iostream
	cpp.modules: https://blog.feabhas.com/2021/08/c20-modules-with-gcc11/
	cpp: cppinclude is a program to analyze file includes https://github.com/cppinclude/cppinclude
	cpp: Cursed idea: #define implicit explicit(false)
	ext: For utf ranges check out: https://github.com/tcbrindle/utf_ranges
	glsl: Blend function implementations (with single opacity only) https://github.com/jamieowen/glsl-blend
	ide.clion: console colored log workaround with: disable run.processes.with.pty in CLion (or with system(("chcp "s + std::to_string(CP_UTF8)).c_str());)
	math / glsl: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
	model: Generate texture for LOD meshes
	monitor: DB monitoring https://blog.serverdensity.com/how-to-monitor-mysql/
	monitor: Prometheus DB monitoring https://dzone.com/articles/how-to-monitor-mysql-deployments-with-prometheus-a
	project: Free project related tools (LDjam) https://docs.google.com/spreadsheets/d/1tfkBo2IWLHXkZDbIEFUyCWvLkumHYDWCxGHzb-Rmc-0/edit#gid=0
	sound: Sound effect generator: http://www.drpetter.se/project_sfxr.html
	voice-chat: If I ever want to implement voice chat: https://opus-codec.org/

	icon_sets: https://icon-sets.iconify.design/

	ux: Game opening sound (menu music or intro animation) is extremely important, it should always be pleasant and not intrusive
	ux: On actions that are meant for list entries (delete or edit list element) the action should be placed in the row. Selecting an entry then pressing a button on a different location on the UI is very cumbersome
	ux: Two step user mouse interaction feedback:
			1) Instant hard and visible change in color or shape
			2) Slow animation that eases into a final color or shape
			The first provides shard feedback while the second gives it a fancy kick
	game.architect: Networking: To get a free networking integration prepare simulation in a way, that any input action is serialized into data/message first, then apply that data/message

	5 step design
		Make the requirements less dumb
		Try very hard to delete the part or process
		Simplify and optimize the design
		Accelerate cycle time
		Automate

glew: Investigate: every context requires its own glewinit call (Some builds of GLEW are multi context aware and do this internally.)


libv.ctrl: rename every "scale" to "multiplier"

app.fsw: libv.arg-ify
app.enum: libv.arg-ify
app.bin_to_src: libv.arg-ify
app.bin_to_src: command line argument for line length
app.bin_to_src: use std::span<const std::byte>
app.bin_to_src: use // <editor-fold defaultstate="collapsed" desc="Binary data ..."> and // </editor-fold>


Naming changes:
	libv.utility: Naming for bit extract: I originally thought about using set/get pair, but extract/deposit are used in asm and bit world
	libv: (?) naming change: func_optional -> func_opt
	libv: (?) naming change: func_or_throw -> func_throw
	libv: (?) naming change: func_ec       -> func_ec    (unchanged)
	libv: (?) naming change: func_or       -> func_or    (unchanged)


IDE:
	ide: Use MSYS2_HOME env var for toolchain settings in IDEs | to help with sharing IDE project files

	IDE	Colors:
		BBBFC3
		B5B6E3
		5F8C8A

		enum decl - C76863
		enum usage - 9FB4C7
		enumerator decl - 579058
		enumerator usage - 579058

	CLion:
		Fixable: wrong working directory to run in
			(generally the relationship between bin and res should be solved too)
				? arg for res folder
				? auto discover 1 folder up
			| Solved with setting each IDE target
			| Re-Solved it with detection and auto change of directory

		Issue: TODO list is shit
			| a separate app that I make could solve it that calls back to CLion

IDE live templates:
	Netbeans and CLion:
		for - // Unify, for int i = 0; i < 10; i++
		fori - // Unify, Iterator version
		fora - // Unify, const auto& v : range
	Netbeans:
		pimpl
			class $CLASS$ {
			private:
				std::unique_ptr<class Impl$CLASS$> self;

			public:
				$CLASS$();
				~$CLASS$();
			};

			$CLASS$::$CLASS$() :
				self(std::make_unique<Impl$CLASS$>()) {
			}

			$CLASS$::~$CLASS$() {
				// For the sake of forward declared ptr
			}
		str - std::string
		strv - std::string_view
		coutv
			std::cout << "$COPY_OF_VAR$: " << $VAR$ << std::endl;$END$
		mv - std::move(args)
		fw - std::forward<Args>(args)
		fwa - std::forward<decltype(args)>(args)
		fwp - std::forward<Args>(args)...
		ci - var(var)                  // Remove the comma from the netbeans version
		cim - var(std::move(var))
		get -
			[[nodiscard]] constexpr inline $TYPE="const auto&"$ $VAR$() const noexcept {
				return $VAR$_;
			}
		getr -
			[[nodiscard]] constexpr inline auto& $VAR$() const noexcept {
				return $VAR$_;
			}
		getc -
			[[nodiscard]] constexpr inline const auto& $VAR$() const noexcept {
				return $VAR$_;
			}
		getv -
			[[nodiscard]] constexpr inline auto $VAR$() const noexcept {
				return $VAR$_;
			}
		nd - [[nodiscard]]
		un - [[maybe_unused]]
		ft - [[fallthrough]]
		no - noexcept
		cc - copy ctor and assignment
			constexpr inline $TYPE$(const $TYPE$&) $CC_IS_NOEXCEPT$= default;
			constexpr inline $TYPE$& operator=(const $TYPE$&) & $CC_IS_NOEXCEPT$= default;
		mc - move ctor and assignment
			constexpr inline $TYPE$($TYPE$&&) noexcept = default;
			constexpr inline $TYPE$& operator=($TYPE$&&) & noexcept = default;
		ctor
			constexpr inline $TYPE$(const $TYPE$&) $CC_IS_NOEXCEPT$= default;
			constexpr inline $TYPE$& operator=(const $TYPE$&) & $CC_IS_NOEXCEPT$= default;
			constexpr inline $TYPE$($TYPE$&&) noexcept = default;
			constexpr inline $TYPE$& operator=($TYPE$&&) & noexcept = default;
		lock - auto lock = std::unique_lock($VAR$);



libv.utility: non repeating random numbers: lottery problem, on collusion shuffle to back

libv.ctrl: "alterator_feature" (with better name, maybe mode_feature) -> only stateful, like hold shift to show more information | its kind of an analog with ignored value, but not really, and it would be nice to have state getter for this, and that would make it a binary, but with properly guarded
libv.ctrl: save xls from thesis archive


ext.x3: make sure that every rule is static, BUT ! What about static initialization order fiasco?
	libv.parse: move x3 parse rules to globals with internal linkage to improve performance
ext.x3: make sure that no header dependency exposed by libv parsers (headers)

libv.ctrl: clean up visibility (especially for Sequence and StateSequence and related types) cleanup distant member accesses (from control)
libv.ctrl: introspection API should not see stated types | info type proxies | maybe even pimpl
libv.ctrl: Binding binary operation setting and serialization

libv.ctrl: InputID, Input, AIA and DIA should be merged this way: both Input and InputID should be 64bit types, but one should contain the action related information, they should be converted to one another with extra info or info loss, inheritance or CRTP might save some work

libv.ctrl: More specialized binding can hide normal feature if there is not context under it -> the order of context existence check and binding specialization test should be flipped
libv.ctrl.routing: Unrelated analog event cancels button sequence
libv.ctrl: Feature collection is collecting empty functions too


libv.ctrl: Sequence: dead-key like behaviour
		process analog will need to differentiate between mouse and analog, but that is already needed for, or not, at least not yet, something got cancelled with this one

		if there are dead-keys active
			only consider dead-key set bindings
		otherwise
			consider every binding

		if a combination got fulfilled
			if it was a sequence's non-last combination or if it was not a sequence
				collect into normal list
			else
				collect into ongoing_sequence list

		select and filter (normal list AND ongoing_sequence list)
		remove elements from ongoing_sequence that were not selected
		broadcast among selected normal list


		if (not ongoing_sequence.empty())
			store ongoing_sequence as dead-key set and therefore enter dead-key mode


		when to cancel a dead-key situation
		if we are in a dead-key situation and any of the following occurs
				event: that is not part of any new combination in dead-key set
				event: not an opposite or holding of the previous history step of dead-key set
				on time: sequence_timeout
			then cancel dead-key situation by clearing the dead-key set and discarding the event




libv.ctrl: Paper
	TODO notes:
		Issue: Binding input sub sequence collusion
			Given 'Shift + E' and 'E' binding, inputting 'Shift + E' will incorrectly satisfy both
			Mistake:
				Assumption: Inputs are serial
				Reality: Input might be parallel (Throw grenade with Shift + F while WASD active)
				Additional note: Multi combination inputs are expected to be serial at all times.
				Additional note: Due to this, heuristic might be acceptable?

			Solution A: (heuristic) prefer the more specialized bindings (? based on setting of the binding) | causes issues with non valid shortcuts matching a smaller one
			Solution B: (at most internally) specify as the E version as not pressed: Shift [free] + E
			Solution C: modifier bits, but that would introduce the inability to define custom modifiers
			Solution D: per binding exclusivity definition:
				- yield toward more specialized
				- require exclusivity
				- ignore independent
				- allow non-interfering independent changes
				- allow non-interleaving independent states
				- ...

			Solution placement 1: controls settings
			Solution placement 2: per binding
			Solution placement 3: per feature

				Research required: both source and usage examples in multiple domain and programs
				Document findings
				Research required: feature based interruptibility matrix

			Additional note:
				Callbacks passed events could/should have an absorb flag. Binding and features could demand certain absorbs properties like only one absorb or allow subset sequences to be fired or allow parallel and so on...

		Issue: Need 2D input support (?), for example pie menu needs it too | that is UI absolute position

		Click - Press > at most X time > Release
		Double Click - Press > at most X time > Release > at most T time > Press > at most X time > Release

	Outside of scope notes:
		Issue: need a way to prevent scale above 1 on certain D->A time based bindings
			Solution: just a flag for the analog feature to clamp scale to 0..1 or -1..1 before multiplying with time

		Hidden features: option to register feature as non listable, but settable
		Hidden binding: option to register a non listable binding, but still settable

		Press type aka additional information on binding (AKA A/D converter):
			N/A, Continuous (Hold), Press, Release, Double click, (Toggle), etc...
			Threshold, Scale, Repeat rules, Offset, Ramp-up

	input sources:
		keyboard
			codepoint = codepoint resolution into keycode/scancode + warning on the UI unless it is part of the safe (A-Z0-9 and (?) more) range
			keycode
			modifier
			scancode = warning on the UI
		mouse
			button
			scroll
			move
		gamepad (and gamepad any)
			button
			analog
		joystick (and joystick any)
			button
			analog
		time
		events (API)
		context (API)

	input type (used for binding information)
		button - select state change edge
		analog (as joystick or gamepad) - linearization, deadzone
		movement - normalization px to 0..1

	digital input action:
		press   - input::press
		release - input::release
		repeat  - input::repeat
		any     - maps to press, repeat, release
		hold    - event on each frame if input is 1 (held down)
		free    - event on each frame if input is 0 (released) (virtual, disabled to due logic)
		auto    - maps to press, release and hold depending on output

		tap - for <N sec                      (outside of scope of initial release) (digital)
		double tap - for <N sec within <M sec (outside of scope of initial release) (digital)
		hold - for N sec                      (outside of scope of initial release) (analog or digital)

	additional binding operation on analog features:
		scale (includes invert with negative scale)
		(?) position
		(?) difference
		(?) dimension select
		(?) dimension direction select
		(?) dimension convert
		(?) threshold
		(?) multiple analog
		(?) gamepad axis dead-zone
		(?) gamepad axis linearization

	binding exclusivity:
		???

	additional presentation:
		ability to list every feature
		ability to list every binding
		ability to list every warnings / errors
		ability to search in features / bindings
		ability to search in features / bindings based on the current state
		ability to search in features / bindings based on input sequence

	interesting usages examples, things to investigate:
		app.editor.manipulator.grab = Left Mouse
		app.editor.selection.move_x = X + Mouse X * 2
		app.editor.selection.to_upper = Ctrl + U, U

		half control - how would walk forward and walk forward toggle look like

		circle_quick_menu and mouse position | real name found: pie menu
			app.editor.circle_quick_menu.open = Ctrl + Space
			app.editor.circle_quick_menu.select = Click
			app.editor.circle_quick_menu.select = Space
			app.editor.circle_quick_menu.switch = Mouse // How would this one work?
			app.editor.circle_quick_menu.ccw = Up
			app.editor.circle_quick_menu.ccw = Left
			app.editor.circle_quick_menu.cw = Down
			app.editor.circle_quick_menu.cw = Right

		right click to move command, long right click to move command with final direction/shape


libv.ctrl: Per binding decision of collusion handling by the user: priority, fall through, stop, stop if successful (feature can yield success or failure), call order, etc
libv.ctrl: In feature callback ability to reject the event/binding and allow the next candidate to be called
libv.ctrl: Binding profiles, and inheritance
libv.ctrl: Gamepad/joystick analog should be time related, but mouse and scroll are event based
libv.ctrl: Click and double click support would be nice
libv.ctrl: User should not be exposed to stated sequence (binding does that)
libv.ctrl: Idea: Stated and normal sequence common templated base class (?)
libv.ctrl.parse: identifier parsing (_ skipper or adjusting infos to match current parser)
libv.ctrl: Routing: Select sequence progression (beside bindings) based on more specialized

libv.ctrl: Integration queue:
	libv.frame.input: Add support for joysticks and game-pads

	libv.ctrl: review glfwGetKeyName http://www.glfw.org/docs/latest/group__keys.html
	libv.ctrl: review glfwSetInputMode http://www.glfw.org/docs/latest/group__keys.html
	libv.frame.input: Added glfwGetKeyName for querying the layout-specific name of printable keys
	libv.frame.input: Added glfwGetKeyScancode function that allows retrieving platform dependent scancodes for keys (#830)

	glfw.joystick: Added glfwGetGamepadName function for querying the name provided by the gamepad mapping (#900)
	glfw.joystick: Added glfwGetGamepadState function, GLFW_GAMEPAD_* and GLFWgamepadstate for retrieving gamepad input state (#900)
	glfw.joystick: Added glfwGetJoystickGUID function for querying the SDL compatible GUID of a joystick (#900)
	glfw.joystick: Added glfwGetJoystickHats function for querying joystick hats (#889,#906,#934)
	glfw.joystick: Added glfwJoystickIsGamepad function for querying whether a joystick has a gamepad mapping
	glfw.joystick: Added glfwSetJoystickCallback for joystick connection and disconnection events
	glfw.joystick: Added glfwSetJoystickUserPointer and glfwGetJoystickUserPointer for per-joystick user pointers
	glfw.joystick: Added glfwUpdateGamepadMappings function for importing gamepad mappings in SDL_GameControllerDB format

libv.ctrl: Implementation queue:
	libv.ctrl: Split analog dimension to dimension and aia
	libv.ctrl: Clamped analog (feature or control type that can only be 0..1 in a 1 sec time frame)
	libv.ctrl: Feature middle ground is missing: Input > Binding > Feature > Feature Instance > callback
				In other word: an additional type between the current binding and feature, this would clean up string operations
	libv.ctrl: Contexts information, state collusion information among contexts, use that for queries
	libv.ctrl: Idea: Analog/Action fulfilment hold satisfied for small time | SOLVED BY MOVING ANALOGS TO TIME BASED (also multi analog combination is no longer a problem)
	libv.ctrl: Identifier level to_string should be parsable
	libv.ctrl.parse: Quirk: Combination parsing bug on '+'+' would mean reverse order | Forward parsing would solve it
	libv.ctrl.parse: Quirk: Symbol ' has to contain an extra space because parsing error around + and ,
	libv.ctrl.parse: x3::eoi could improve matching, relax orders, optimize for most probably input
	libv.ctrl.parse: Quirk: word_plus and word_minus could have p/m due to the forbidden reverse order in mouse movement, test cases are required
	libv.ctrl: DigitalInputAction/(?)AnalogInputAction could be folded into InputID's reserved 8 bit, aliasing and specialization would have to follow | this would also fold InputID into Input
	libv.ctrl: Binding two separate additional information form | This is important, this is the core solution!: Input based, Feature based (and operation based)
	libv.ctrl: event/feature chain interruptibility on colliding bindings:
				add member to event: is_ambiguous
				add member to event: is_consumed and consume (or whatever it is called in ui similar event pattern)
	libv.ctrl: Invalid sequence automated fixup | only if there is consent
	libv.ctrl: In parsing Gamepad Button-s make word_button optional, maybe make gamepad selection more distinct
	libv.ctrl: In parsing Joystick Button-s make word_button optional if possible, maybe make joystick selection more distinct
	libv.ctrl: binding levels should be grouped primaries for keyboard or gamepad, also it need a way to switch them, maybe assign group or groups to bindings
	libv.ctrl: feature registration show provide way for custom properties
	libv.ctrl: hash based binding index for event where manually map everything to the most similar form
	libv.ctrl: why can I not x3::attr InputID directly (it just default constructs it and drop the value on the floor)
	libv.ctrl: More introspection is possible: search feature by context with or without name
	libv.ctrl: More introspection is possible: search binding with feature and sequence
	libv.ctrl: More search possible: search_mode::wildcard (with . as the level separator)
	libv.ctrl: More search possible: search_mode::any_word (with space as the word separator)
	libv.ctrl: More search possible: search_mode::all_word (with space as the word separator)
	libv.ctrl: Super flatten sequence and stated sequence
	libv.ctrl: check_binding and check_feature are algorithm that should be generalized
	libv.ctrl: Change in codepoint mapping can cause events with codepoint based inputs

	libv.ctrl.profile: each binding entry would select: inherit (noop) / override / extend its parent binding entry

	libv.ctrl: Idea: why not require codepoints to be inside the inputs events
	libv.ctrl: Idea: dia as bitmask
	libv.ctrl: Rep source type could be signed and analogs on negative, buttons on positive values
	libv.ctrl: Ability to list every (active) context
	libv.ctrl: Bind and profile api and serialization: override, empty override, append
	libv.ctrl: A serialization... A serious one
	libv.ctrl: Solve FeatureRegister code duplication with inheritance (FeatureRegister even could be a base of Controls)

	libv.ctrl: Context level feature containers, or index so lookup faster (?)
	libv.ctrl: Store more information about Context. Name, orthogonal and concurrent contexts
	libv.ctrl: Idea of context groups, and under a group there are multiple types

	libv.ctrl: IDEA: Soft enter contexts:
			Soft enter would allow on demand context change based on unhandled events
			Scenario:
				A UI Object is focused
				Mouse is above a canvas and no longer above the UI component
					The Mouse hover effect marks the canvas to soft enter
				On the canvas there is a binding for 'F1'
				'F1' is pressed but no active context handles it
				Soft entered contexts could auto enter and handle the event

app.vm4_viewer: light source indicator
app.vm4_viewer: light source mover
app.vm4_viewer: ortho camera, and swapping

app.vm4_viewer: Rulers: Display size rulers along the 3 dimension (3/6/9 value) of the max ranges

app.vm4_viewer: Run time (and config time) options for debug tool toggles, or overlays: ui toggle buttons
app.vm4_viewer: Add config option to auto open shader on errors: /netbeans/bin/netbeans64.exe --open {file}:{line}
app.vm4_viewer: Add config option to disable reset camera on model loading
app.vm4_viewer: Add config option for AABB
app.vm4_viewer: Add config option for BS
app.vm4_viewer: Add config option for grid-XY
app.vm4_viewer: Add config option to not reset camera on model change

libv.args: support or extension for the lib to support command line "late" commands, from a different process instance with a network hook
app.vm4_viewer: Command line argument --open "file" to auto open file
app.vm4_viewer: Command line argument --active open file in already running instance (overrides config option)

> Render Data Dependency Graph aka Scene structure reorganization
	Node
		string name
		Node*[] children

	Object : Node
		transformation

	Scene
		Camera
		Model
		Light[]
		Shader[]

	Camera : Object
		camera properties

	Model : Object
		gl::mesh
		Material[]
		vm4::model

	Shader
		texture channels
		gl::uniform location miscellaneous
		gl::uniform location transformation
		gl::uniform location light[]
		gl::uniform location material[]

	Light : Object
		light properties

	Material
		Shader*
		material properties

	Texture
		map type (channel)
		gl::texture


gl: learn https://www.khronos.org/opengl/wiki/Image_Load_Store

libv.gl.glsl: Warning for abs          include path (path normal form start with root)
libv.gl.glsl: Warning for non base-abs include path (path normal form start with ..)
libv.gl.glsl: Warning for non generic directory separator in include path (backlash)
libv.gl.glsl: Warning option for mixed indentation in different lines and/or files
libv.gl.glsl: Warning for line trailing white space

app.vm4_viewer: camera movement should acquire and mutex mouse position

app: about page with executable path, build and compiler information, git hash and software version
libv.main: Small library to wrap main and command line arguments into a modern C++ format with global access: span<string_view>

ext: cryptopp https://github.com/weidai11/cryptopp
libv.vm4: model hash (calculated at import)
libv.vm4: model import timestamp

libv.vm4lua: lua binding for vm4 and vm4 importer

glsl: quaternion https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl and http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/
app.vm4_viewer: display statistics

app.vm4_viewer: import model
app.vm4_viewer: Add project level size comparison functionality
app.vm4_viewer: Thumbnails and thumbnail generation
app.vm4_viewer: Better focus camera based on the actual view angles and model ineast of the BSO

app.vm4_viewer.shader: uniform (sun) auto iteration and name auto chaining
app.vm4_viewer.shader: ui feedback for glsl shader reload success
app.vm4_viewer.shader: ui feedback for glsl shader failed include
app.vm4_viewer.shader: use a fallback shader on init failure
app.vm4_viewer.shader: do not notify success on first shader init, it is not needed

libv.console: new console lib? A UI component will also be needed for it, but the backend should work without gui
libv.console: should depend on libv.arg


--- Checkpoint ---


libv.[lua|eval]: A small [lua] engine that can be used in the ui for number inputs with support to math expressions
		CHECK(eval(context, "3           ") == 100);
		CHECK(eval(context, "3.14        ") == 100);
		CHECK(eval(context, "pi          ") == 100);
		CHECK(eval(context, "sin(pi)     ") == 100);
		CHECK(eval(context, "360 / 21    ") == 100);
		CHECK(eval(context, "pi * 2      ") == 100);
		CHECK(eval(context, "a           ") == error);
		CHECK(eval(context, "a = 42      ") == 42);
		CHECK(eval(context, "a           ") == 42);
		CHECK(eval(context, "a + 2       ") == 44);
		CHECK(eval(context, "b           ") == error);
		CHECK(eval(context, "foo(42)     ") == error);
		//CHECK(eval(context, "function foo(x) return x end foo(42)") == error);
		context.add("function foo(x) return x end");
		CHECK(eval(context, "foo(42)     ") == 42)
		CHECK(eval(context, "function g(x) return x end") == error)

libv.utility: Implement a proper match file iterator "dir/part*.cpp", possibly with filesystem + ranges | use wildcard functions, but split pattern / match for performance | design API allow async/iterative (give next N passed entry or M failed (not matched) entry)

app.vm4_viewer: implement a small light gui app to provide guidance to GUI development
app.vm4_viewer: display statistics of texture density and estimated texture pixel world space size

libv.sig: merge back the sig codebase rework a lighter version of the lib
libv.gl: move glew init into GL (with the ability to optionally disable it with a constructor argument)

libv.glr: (?) (if passible) std140 implementation should be moved to libv.gl
libv.glr: layout_to_string.hpp stream_struct_name test / use #include <boost/type_index.hpp> boost::typeindex::type_id_with_cvr<T>.pretty_name()

wish: update cmake version and use add_compile_definitions() instead of add_definitions()
wish: target_link_directories()
wish: add support for OUTPUT_NAME and use it for the apps https://cmake.org/cmake/help/latest/prop_tgt/OUTPUT_NAME.html
wish: use include guards https://cmake.org/cmake/help/v3.14/command/include_guard.html#command:include_guard
wish: correct cmake target private/interface/public dependency (link and include (and source and definitions)) usage https://www.youtube.com/watch?v=y7ndUhdQuU8
wish: revisit catch object file linkage (only need to figure out a way to build it) as "target_link_libraries() command now supports Object Libraries"
wish: add a dummy.cpp to targets that would require at least one source file but GLOB was empty

libv.ppc: new Pre-Processor Compiler library, a cpp "like" pre-processor implementation for shader loading

libv.color: New libv.color library, color space conversion and manipulations, template color space, template representation
libv.color: implement HCL and other color conversion functions http://www.chilliant.com/rgb2hsv.html
libv.ui: Color picker

libv.glr: MAYOR OVERHAUL: remove the queue, use thread local GLR context variable access, remove the idea of sorting, switch to immediate mode
		| NOTE: uniform streams do rely on the queue, so any code using them will have to change

libv.glr: Cleanup includes for:
			libv/glr/mesh.cpp
			libv/glr/mesh.hpp
			libv/glr/program.cpp
			libv/glr/program.hpp
			libv/glr/uniform_buffer.cpp
			libv/glr/uniform_buffer.hpp
			libv/glr/uniform_stream.hpp
libv.glr: Implement head pattern for:
			libv/glr/mesh.cpp
			libv/glr/mesh.hpp
			libv/glr/program.cpp
			libv/glr/program.hpp
			libv/glr/uniform_buffer.cpp
			libv/glr/uniform_buffer.hpp
			libv/glr/uniform_stream.hpp
			libv/glr/framebuffer.cpp
			libv/glr/framebuffer.hpp
			libv/glr/texture.cpp
			libv/glr/texture.hpp
libv.glr: GLR User facing API shall not expose to the OpenGL header
libv.glr: better name for DestroyQueue (? and use thread local acces for it)
libv.glr: libv/glr/remote.hpp only included in glr files to fetch DestroyQueue, pass that around instead (with a better name), could be boundeled with the gl reference.
libv.glr: create bool -> remote == nullptr | or negative index

libv.glr: too many variant, function / arg streams?, uniform_stream has a similar pattern that could be generalized

libv.gl: Check on TextureRect if it is working properly (attempted to use it in font2D but failed, image was correct indexing/sampler issues (?))

libv.glr: Mesh attributes inside the remote should be stable, vector<unique_ptr<Attribute>>
libv.glr: Mesh attributes should use a single VBO

libv.glr: Procedural gizmo mesh


--- Checkpoint ---


libv.ui: constraints: a way of syncing data between the world and the ui
libv.ui.layout: Flow
libv.ui.layout: 2D <-> 3D based on game state
libv.ui: ui <-> 3D layout linkage: planet names and additional information is part of the ui and not the scene
		ui therefore has to access the game state (trivial, but this code has to happen now)

libv.glr: strong type locations and indices with enum classes, also use libv::gl::uniform
libv.glr: Fix uniform naming mess, Reduce the number of public members

libv.glr: vm4 | non trivial
libv.vm4: in model header include version
libv.vm4: in model header include date
libv.vm4: in model header include hash
libv.vm4: geomax / geoorig: find the biggest distance between any two vertex, avg(a, b) = geoorig, dist(a, b) / 2 = geomax
libv.va4/ia4: (Iris/Vader Asset 4) New "library" to handle vm4 models and bundle them.
libv.va4/ia4: Animation drivers: look at, rotate around world/local xyz, pulsate, play animation, etc...

libv.gl: https://learnopengl.com/PBR/Lighting
libv.glr: post-processing haze

libv.glr: Shadow
libv.glr: Cascaded shadow maps
libv.glr: Use instanced render for world shadow pass and clip with gl_ClipDistance[i] / glEnable(GL_CLIP_DISTANCEi);
libv.glr: Tiled Forward Shading (aka Forward+) https://www.3dgep.com/forward-plus/
libv.glr: Volume Tiled Forward Shading https://www.3dgep.com/wp-content/uploads/2017/07/3910539_Jeremiah_van_Oosten_Volume_Tiled_Forward_Shading.pdf
libv.glr: Deferred-Shading https://learnopengl.com/Advanced-Lighting/Deferred-Shading and https://www.3dgep.com/volume-tiled-forward-shading/
libv.glr: SSAO https://learnopengl.com/Advanced-Lighting/SSAO
libv.glr: Exposure https://learnopengl.com/Advanced-Lighting/HDR
libv.glr: FXAA
libv.glr: SRAA
libv.glr: Tiled-Deferred-Shading
libv.glr: Order Independent Transparency (OIT)


--- Checkpoint ---


libv.ecui: state based ui, separate control and data

libv.frame: cleanup states by adding a single state for show/hidden/maximized/minimized/fullscreen/borderless_maximized
libv.frame: cleanup monitor, provide a thread-safe access to monitors list
libv.frame: cleanup global variables, at least place them next to each other and reason about thread access
libv.frame.input: Question should I couple scancode with key for each key states | observe use-case
libv.frame: remove clipboard support, ext clip will take care of it.

libv.utility: pointer facade for: observer_ptr, observer_ref, etc...

ext.sol2: update and there is a new fwd header, use it if/where appropriate: sol_forward.hpp
cpp: enun class default underlying type is int, specify underlying type for every enum class
cpp: check if every possible operator had been made to a hidden friend
cpp: check if i have any recursive variadic function that is not using if constexpr but uses a tail overload
libv.gl: use mdspan for image updates instead of raw loops
libv.gl: learn glPixelStore / implement
libv.gl: glsl preprocessor support for "#pragma vertex" and "#pragma fragment" to auto split files, useful for small test and debug shaders

libv.glr: texture, do not store the whole image, only have pending chunks, this will get rid of a lot of memcopy nightmare
libv.glr: optimize every remote resource with head access
libv.ui: switch of direct glr usage to a UI wrapper bulk renderer
libv.ui: question: for bulk rendering would stencil buffer help for fonts | yes-kind of but alpha makes it tricky
libv.glr: IDEA: An Entry object the group every call/state to a single render operation, both in queue and on the user API
libv.glr: IDEA: Versioned resources, beside what tell which version are we want to use
libv.glr: Make the reordering explicit and opt-in
libv.glr: Refactor the variants

libv.lua: function to immediately destroy a variable (useful for game object or gui object cleanup that would hold a resource otherwise)

libv.math: Catmull-Rom spline https://www.youtube.com/watch?v=9_aJGUTePYo and code https://github.com/OneLoneCoder/videos/blob/master/OneLoneCoder_Splines2.cpp

libv.ui: Could boost::sync_queue be used?
libv.utility: Add lexically_normal to generic_path and cleanup relevant usages

libv.fsw: Improve callback and tokens to not hold the mutex during event broadcast (callback), currently it is a deadlock


libv.audio: Paper
	For audio HARD API BARRIER IS REQUIRED (Every lib / backend is a shitshow)

	Backend possibilities
		Best solution would be audeo at first, but that will pull in the SDL chain, even if it is only used for audio

		OpenAL - License issue: https://github.com/kcat/openal-soft
		PortAudio - Too low level: http://www.portaudio.com/docs.html
			sndfile lib in order to load/save all kinds of audio files.
		audeo - Based on top of SDL_Mixer: https://github.com/NotAPenguin0/audeo
									https://github.com/libsdl-org/SDL_mixer
									https://github.com/libsdl-org/SDL
		soloud - Another good candidate: https://sol.gfxile.net/soloud/quickstart.html
			has many-many backend (even OS native ones), API looks ok, license ok (zlib)

	Sound
		Sound - What to play
		+/- Variations
		+/- Effects /  Filters
		? Other

 	Play
		Sound - What to play
		Channel - What mixing channel should it be played on
		Operation - Start, Repeat, Stop
		Edge - Fade in, Fade out, Normal
		Position or Centered - For positioning [and sound delay]
		[Speed - For Doppler effect]
		+/- Effects / Filters
		? Other

	Option
		Center position - So play can use abs position and not rel
		Center speed - So play can use abs speed and not rel
		Channel volumes
		? Other

	Other
		ducking by over powering volume of sound
		ducking by over powering volume of channel
		ducking by importance of sound
		ducking by importance of channel



--- AWAITING ---------------------------------------------------------------------------------------


async: https://www.youtube.com/watch?v=t4etEwG2_LY
cmake: generator expressions https://cmake.org/cmake/help/v3.8/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7)
cmake: Revisit the external auto rebuild feature, if() + file(TOUCH) + target_dependency() | could I use separate cmake file for each ext and make a dependency on it ?
color: color picker http://www.colorhexa.com/3affce
color.math: colorspace of humans https://en.wikipedia.org/wiki/Lab_color_space
color.math: http://graficaobscura.com/matrix/index.html
color.picker: http://tristen.ca/hcl-picker/#/hlc/10/1/F68385/D1E468
color.picker: HCL picker https://tools.lgm.cl/colorpicker.html
cpp.proposal: P1 member_offset alternative for offsetof macro
		- similar approach is [p0908r0]
		- template <typename T, typename M> size_t member_offset(M T::* ptr) { /* implementation-defined*/ }
cpp.proposal: container.resize_for_overwrite()
		- based on make_shared_for_overwrite just for containers
cpp.proposal: P2 std::uninitialized
		- ability to declare a primitive variable with explicitly uninitialized value
		- int variable = std::uninitialized;
cpp.proposal: P2 add auto ctor call to return MyType(arg0, arg1); => return (arg0, arg1);
		- decltype(auto) foo();
		- auto foo();
		- return (result);
cpp.proposal: std::concat
		fmt format without format string
cpp.proposal: P2 std::argument_with _name<T>: void foo(std::with_call_name<const T&> arg) { std::cout << arg.name << “: ” << args.value << std::endl; }
		void foo(variable) -> void foo(MAGIC(variable)) -> void foo(std::with_call_name{“variable”, variable});
		void foo(exp + ression) -> void foo(MAGIC(exp + ression)) -> void foo(std::with_call_name{“exp + ression”, exp + ression});
		Conversion would only fire after the overload resolution already took place. Or it would count as an implicit user defined conversion
		Questions: Is whitespace included? Newlines? Expressions? Whitespace in expressions? Constexpr? Just do what macros do?
cpp.proposal: P3 unrestricted template template parameters (and template concept parameters)
		template <template<typename...> container> struct S{}; // Current syntax
		template <template              container> struct S{}; // Proposed syntax
		It was always possible to use a wrapper type and traffic such unrestricted template params as member template typedef
cpp.proposal: P3 generalized type pack "using... ", type pack in non template parameter context
		using... types = int, double, std::string;
		std::variant<types...> global;
		Open question: issue of pack disambiguation in dependent name context: "dependent::pack types", "dependent::... types", "dependent::typepack types"
cpp.proposal: P3 structured binding pack
		auto& [...members] = object;
cpp.proposal: P3 vec_t<N, T>, matrix_t<N, M, T>
cpp.proposal: P3 template specialization without opening a namespace
		issue: inline namespace, namespace/class scope disambiguation
cpp.proposal: P4 allow trailing comma for function arguments and lambda captures and init lists, its already there for arrays and enums
cpp.proposal: P4 file watcher
cpp.stacktrace: Seams like a solid alternative for boost.stacktrace https://github.com/bombela/backward-cpp
cpp: (adaptive) radix tree - O(1) lookup
cpp: aligned_storage is UB, use this instead: alignas(T) std::byte storage[sizeof(T)];
cpp: can there be multiple definition error during linkage if two lib contains the same (symbol) definition
cpp: clarify template vs auto type deduction rules
cpp: keyword order: [[nodiscard]] virtual explicit friend static constexpr inline const void&& function() const&& noexcept override final;
cpp: learn std::launder and std::bless
cpp: Apply <stop_token> and std::jthread onto the codebase
doc / blog: Klipse plugin - http://blog.klipse.tech/cpp/2016/12/29/blog-cpp.html
doc: code snippet generation mdsnippets.com https://github.com/simonCropp/MarkdownSnippets
ext.mysql: mysql connector source https://dev.mysql.com/get/Downloads/Connector-C++/mysql-connector-c++-8.0.17-src.tar.gz
ext: adopt a better hash_map and remove every std::unordered container
ext: adopt mdspan https://github.com/kokkos/mdspan/wiki/A-Gentle-Introduction-to-mdspan
ext: adopt zlib (remove assimp internal zlib) https://github.com/madler/zlib (light wrapper for usage: https://gist.github.com/gomons/9d446024fbb7ccb6536ab984e29e154a )
gold: And if thou gaze long at a finite automaton, a finite automaton also gazes into thee.
gold: UNLESS someone like you cares a whole awful lot, nothing is going to get better. It's not.
gold: existence / super-position based predication
learn: https://gafferongames.com/post/state_synchronization/ or just https://gafferongames.com/
math: blue noise, a stable uniform noise https://gist.github.com/pixelmager/5d25fa32987273b9608a2d2c6cc74bfa
net: distributed servers (RAFT joint consensus algorithm) https://raft.github.io/
observe: https://bkaradzic.github.io/bgfx/examples.html
observe: https://github.com/bkaradzic/bgfx
observe: https://github.com/hugoam/mud
resource: dns like resource resolver for custom arguments: Args... -> ResourceDescriptor -> Resource
resource: forbid usage of absolute paths
resource: forbid usage of relative paths with starting ..

libv.serial: Maybe create a hjson archive https://hjson.github.io/
libv.ecs: Provide a component that has a special storage and can work as structure of arrays (SOA) instead of array of structures (AOS) to enable massive use of simd with a special foreach, so the general idea that share the indexing between tiny-tiny sub components
libv.frame: Move frames from disconnected monitor / off-screen
libv.frame: remove default own thread, give them an io_context like executor
libv.gl: templated buffer for binding
libv.gl: uniformbuffer?
libv.log: log thread naming
libv.net: Possible C++20 feature std::ispanstream would allow direct deserialization out from a received packet
libv.net: compression lib (fast, but not the best compression for me) https://github.com/google/snappy
libv.range: view::input_pass resumable range pass: auto pass = range | view::input_pass; for (auto i : pass) fooA(i) if (i % 2) break; for (auto i : pass) fooB(i);
libv.sig: merge back and place meta (too many tamplate argument) into libv.meta, (or dont, please, it is too many template)
libv.ui.layout: think layout as a graph instead of a stack..., just think and see whats going on with that approach
libv.ui.lua: https://www.wowace.com/projects/ace3/pages/ace-gui-3-0-widgets
libv.ui: (shader) Program Descriptor: program is defined by a descriptor (which can be identified with a simple string key), this could also be applied for the rest of the resources
libv.ui: https://www.factorio.com/blog/post/fff-246
libv.ui: strong constraint: It has to keep up with 1000 character/sec input in mid sequence. Why? Because the 7.5cps is a reasonable high typing speed.
libv.utility: Make a proper copy-pastable noisy type
libv: LIBV_ASSERT, LIBV_DEBUG_ASSERT, LIBV_STATIC_ASSERT in utility header

ide.options:
	- profile:
	- built-in:     built-in / plug-in / user-defined
	- type:         string / color / font (or font_effect as one big blob)  / vec(2|3|4)
	- name:         group_a.group_b.item
	- base:         inherit_parent_project / reference(group_a.group_b.item)
	- value:        value / alter / merge: value: rgb() / hex / "string" / x,y,z / ... ; alter: hsl / alter hex / alter x,y,z / ...
	- effect:       value / alter / merge: underline / strikethrough / background
	- scripted:     lua
	profiles can inherit from other profiles
	project profile: each project has a built in profile that can be used for project specific settings
	online profiles / uri based profiles (if changes keep last N old versions, auto fetch on start)
colorpicker:
	- support all color space slider in one tab (all) and in different tabs too
	- support all color spaces, swatches, rgb, hsv, hsl, hcl with each 2x1 dimension change option
	- support auto relax color distances
	- support lua profile reference (?)
	- support lua operations
	- support multi color pick at the same time, mouse select, list select
	- support realtime result preview
	- visualize color distances, distance "bubbles"
	- visualize picked colors in sliders too

libv: generic general binary data storage
		 Name               | Implementation                   | Capacity | Size    | SBO | Heap
		--------------------+----------------------------------+----------+---------+-----+---------
		byte_array<N>       | std::array<byte>                 | N        | N       |  N  | never
		byte_static<N>      | std::array<byte>, size_t         | N        | dynamic |  N  | never
		byte_small<N>       | boost::small_vector<byte, N>     | dynamic  | dynamic |  N  | above N
		byte_dynamic        | std::vector<byte>                | dynamic  | dynamic |  -  | above 0
		byte_cold           | byte*                            | fixed    | fixed   |  -  | above 0
		byte_very_cold      | int32_t (index to global byte**) | fixed    | fixed   |  -  | above 0

		binary<-1>          | binary_dynamic
		binary<0+>          | binary_array

libv: generic general container storage
		 Name                    | Implementation            | Capacity | Size    | SBO | Heap
		-------------------------+---------------------------+----------+---------+-----+---------
		vector_static<T..., N>   | std::array<T, N>          | N        | N       |  N  | never
		vector_local<T..., N>    | std::array<T, N>, size_t  | N        | dynamic |  N  | never
		vector_small<T..., N>    | boost::small_vector<T, N> | dynamic  | dynamic |  N  | above N
		vector_dynamic<T...>     | std::vector<T>            | dynamic  | dynamic |  -  | above 0
		vector_cold<T...>        | T*                        | fixed    | fixed   |  -  | above 0
		vector_very_cold<T...>   | int32_t (+ global T**)    | fixed    | fixed   |  -  | above 0

		vector<static<N>, T...>  | std::array<T, N>          | N        | N       |  N  | never
		vector<local<N>, T...>   | std::array<T, N>, size_t  | N        | dynamic |  N  | never
		vector<small<N>, T...>   | boost::small_vector<T, N> | dynamic  | dynamic |  N  | above N
		vector<dynamic<N>, T...> | std::vector<T>            | dynamic  | dynamic |  -  | above 0
		vector<cold, T...>       | T*                        | fixed    | fixed   |  -  | above 0
		vector<very_cold, T...>  | int32_t (+ global T**)    | fixed    | fixed   |  -  | above 0

--- NOTE -------------------------------------------------------------------------------------------

app: for apps you can cd next to the binary to solve any relative path issue (command line arguments should be handled beforehand)
bash: To repleace first line in files: sed -i '1s/.*/\/\/ Created on 2020.05.01. 10:30, Author: Vader/' *
clion: -G"Ninja" -DCMAKE_BUILD_TYPE=RELEASE -DSKIP_EXTERNAL_CONFIGURES=FALSE -DFORCE_COLORED_OUTPUT=TRUE
cpp: C++ has a nice nested exception facility: std::throw_with_nested(std::runtime_error("Outer operation")); and std::rethrow_if_nested(e);
cpp: hash_maps: https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/
git: Commit count up to a revision: git rev-list --count HEAD
ninja: CLICOLOR_FORCE=1 env var to have colored output
UX: For windows position history: Remember not just position and size but if it was in maximized state or not (clion fucked it up, and it show a pixel line on a secondary monitor)
UX: Upon first run avoid full-screening a desktop app by default, this makes it less scary, less intrusive and leave the clint more in control

--- INFO -------------------------------------------------------------------------------------------

Servers:
	{"rs0.corruptedai.com", 25090},
	{"rs1.corruptedai.com", 25091},
	{"rs2.corruptedai.com", 25092},
	{"rs3.corruptedai.com", 25093},
	{"rs4.corruptedai.com", 25094},
	// {"rs5.corruptedai.com", 25095},
	// {"rs6.corruptedai.com", 25096},
	// {"rs7.corruptedai.com", 25097},
	// {"rs8.corruptedai.com", 25098},
	// {"rs9.corruptedai.com", 25099},

Extensions: Used default file extensions in LIBV
	.vm4 - vader model 4
	.vup - vader update patch
	p01.00.patch - p{new}.{old}.patch - patch file naming convention
	iris.01.00.patch - {program}.{new}.{old}.patch - patch file naming convention
	program.variant.01.00.patch - {program}.{variant}.{new}.{old}.patch - patch file naming convention
	program.variant.01.00.update - {program}.{variant}.{new}.{old}.update - patch file naming convention

Files: Used default file names in LIBV
	.lock - active write opened lock file
	.manifest - manifest file in the root directory
	.patch - patch_progress log file

Ports: Used default port ranges in LIBV
	10022 - SSH
	10122 - SSH (tunnel for ca-rs0-dev)
	22001 - SSH (tunnel for ca-web-dev)
	18080 - Jenkins

	[25080-25089] - Network Sandboxes
		25080 - app.space

	25090 - Update server listening
	25091 - RESERVED
	25092 - RESERVED
	25093 - RESERVED
	25094 - RESERVED
	25095 - RESERVED
	25096 - RESERVED
	25097 - RESERVED
	25098 - RESERVED
	25099 - RESERVED


--- ABANDONED --------------------------------------------------------------------------------------

logger: binlog - https://www.youtube.com/watch?v=FyJI4Z6jD4w
logger: client - network connected different app (real time log viewer) with retrospective and real-time filtering and stuff...
cpp.compile: things I want to know about my compile time:
		- Instantiation time, count, location and arguments for every template and their size in binary (inline = 0)
		- List of headers included for every translation unit
		- Size of the resulting translation unit
		- Symbol content of the translation unit
		- Lists of translation units that includes (even if transitively) a given header
		- clang patch: https://www.youtube.com/watch?v=NPWQ7xKfIHQ
		- record in CI history per commit changes in every statistics
		- https://github.com/google/bloaty
		- https://github.com/mikael-s-persson/templight
		- https://www.cppdepend.com/

// -------------------------------------------------------------------------------------------------

GLFW Update:

glfw.core: Added glfwGetError function for querying the last error code and its description
glfw.core: Added glfwInitHint for setting initialization hints
glfw.core: Added glfwSetErrorCallback, GLFWerrorfun and error type tokens for receiving error notifications
glfw.core: Added glfwSetMonitorUserPointer and glfwGetMonitorUserPointer for per-monitor user pointers

glfw.frame: Added glfwCreateCursor, glfwCreateStandardCursor, glfwDestroyCursor and glfwSetCursor for managing system cursor images
glfw.frame: Added glfwGetWindowOpacity and glfwSetWindowOpacity for controlling whole window transparency (#1089)

glfw.input: Added glfwRawMouseMotionSupported function for querying raw motion support (glfwRawMouseMotionSupported must be checked)
glfw.input: Added GLFW_RAW_MOUSE_MOTION input mode for selecting raw motion input (#125,#1400,#1401)

glfw.sample: Added 'cursor' simple cursor test programs
glfw.sample: Added 'empty' test program for verifying posting of empty events
glfw.sample: Added 'modes' video mode enumeration and setting test program
glfw.sample: Added 'sharing' simple OpenGL object sharing test program
glfw.sample: Added 'threads' simple multi-threaded rendering test program
glfw.sample: Added 'windows' simple multi-window test program

glfw: glfwSetMonitorUserPointer and glfwGetMonitorUserPointer
glfw: glfwSetGammaRamp

// -------------------------------------------------------------------------------------------------

Base class for lights and cameras

http://www.cmake.org/cmake/help/v3.3/command/configure_file.html

Optimized compiling - cmake https://github.com/sakra/cotire

CMake resource folder
Cube / Sky Textures http://sourceforge.net/projects/spacescape/

http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html
OpenGL Reference page: https://www.khronos.org/registry/OpenGL-Refpages/gl4/

Shader types
	Fresnel shader - Atmosphere
	Cook-Torrance shader - Metal
	Minnaert - More depth?
	OrenNayar - More avg lambert

--- PASTEBIN ---------------------------------------------------------------------------------------

// Planned attribute locations:
//   0  |     position  |             |
//   1  |       normal  |     psize   |
//   2  |               |   diffuse   |
//   3  |               |  specular   |
//   4  |   boneweight  |             |
//   5  |  boneindices  |             |
//   6  |      tangent  |             |
//   7  |    bitangent  |             |
//   8  |    texcoord0  |             |
//   9  |   tessfactor  |  texcoord1  |
//  10  |     instVec0  |  texcoord2  |
//  11  |     instVec1  |  texcoord3  |
//  12  |   instMatrix  |  texcoord4  |
//  13  |     ^^^^^     |  texcoord5  |
//  14  |     ^^^^^     |  texcoord6  |
//  15  |     ^^^^^     |  texcoord7  |

// -------------------------------------------------------------------------------------------------

Additional cmake.wish ideas:

wish_config(
	TARGET                      __PARENT_TARGET_____TARGET__
	FOLDER                      __PARENT_FOLDER__/__TARGET__
	ALIAS                       __PARENT_ALIAS__::__TARGET__
	SOURCE                      src/__FOLDER__/*.cpp
	HEADER                      src/__FOLDER__/*.hpp

	RESULT_PATH_BINARY_APP      bin/__FOLDER__/
	RESULT_PATH_BINARY_EXAMPLE  bin/__FOLDER__/
	RESULT_PATH_BINARY_SANDBOX  bin/__FOLDER__/
	RESULT_PATH_BINARY_TEST     bin/__FOLDER__/
	RESULT_PATH_HEADER          include/__FOLDER__/
	RESULT_PATH_LIBRARY_DYNAMIC lib/__FOLDER__/
	RESULT_PATH_LIBRARY_STATIC  lib/__FOLDER__/
)

string(LENGTH ${CMAKE_SOURCE_DIR}_ WISH_SHORT_PATH_CUTOFF)
set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
set(THREADS_PREFER_PTHREAD_FLAG TRUE)

find_package(Threads REQUIRED)
find_package(OpenGL REQUIRED)

wish_create_base(
	TARGET libv

	WARNING GNU VERSION_GREATER 7.0 -Wduplicated-branches
	WARNING GNU VERSION_GREATER 7.0 -Wrestrict
	WARNING GNU VERSION_GREATER 7.0 -Wshadow-compatible-local
	WARNING GNU VERSION_GREATER 8.0 -Wcast-align=strict
	WARNING GNU VERSION_GREATER 8.0 -Wmultistatement-macros

	OPTION DEBUG -Og
	OPTION DEBUG -ggdb3
	OPTION RELEASE -O3
	OPTION RELEASE -static
	OPTION DEV -O3
	OPTION -m64
	OPTION -std=c++2a
	OPTION -fconcepts

	DEFINE -Dconcept="concept bool"
	DEFINE -D "WISH_REQUIRES\\(...\\)=\"requires __VA_ARGS__\""
	IDE_DEFINE WISH_REQUIRES(...)

	DEFINE -DWISH_GIT_BRANCH="${WISH_GIT_BRANCH}"
	DEFINE -DWISH_GIT_COMMIT_HASH="${WISH_GIT_COMMIT_HASH}"
	DEFINE -DWISH_SHORT_PATH_CUTOFF=${WISH_SHORT_PATH_CUTOFF}
	DEFINE -DWISH_SHORT_PATH_PREFIX="${CMAKE_SOURCE_DIR}/"
)

wish_create_library(
	PARENT libv
	TARGET vm4imp
	LINK PUBLIC libv::log libv::vm4 ext::assimp
)

// -------------------------------------------------------------------------------------------------

Additional cmake.wish ideas 2:

wish_config(
	TARGET                      __PARENT_TARGET_____TARGET__
	FOLDER                      __PARENT_FOLDER__/__TARGET__
	ALIAS                       __PARENT_ALIAS__::__TARGET__
	SOURCE                      src/__FOLDER__/*.cpp
	HEADER                      src/__FOLDER__/*.hpp

	RESULT_PATH_BINARY_APP      bin/__FOLDER__/
	RESULT_PATH_BINARY_EXAMPLE  bin/__FOLDER__/
	RESULT_PATH_BINARY_SANDBOX  bin/__FOLDER__/
	RESULT_PATH_BINARY_TEST     bin/__FOLDER__/
	RESULT_PATH_HEADER          include/__FOLDER__/
	RESULT_PATH_LIBRARY_DYNAMIC lib/__FOLDER__/
	RESULT_PATH_LIBRARY_STATIC  lib/__FOLDER__/
)

string(LENGTH ${CMAKE_SOURCE_DIR}_ WISH_SHORT_PATH_CUTOFF)
set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
set(THREADS_PREFER_PTHREAD_FLAG TRUE)

find_package(Threads REQUIRED)
find_package(OpenGL REQUIRED)

wish_create_base(
	TARGET libv

	WARNING GNU VERSION_GREATER 7.0 -Wduplicated-branches
	WARNING GNU VERSION_GREATER 7.0 -Wrestrict
	WARNING GNU VERSION_GREATER 7.0 -Wshadow-compatible-local
	WARNING GNU VERSION_GREATER 8.0 -Wcast-align=strict
	WARNING GNU VERSION_GREATER 8.0 -Wmultistatement-macros

	MODE DEBUG
		OPTION -Og
		OPTION -ggdb3
	MODE RELEASE
		OPTION -O3
		OPTION -static
	MODE DEV
		OPTION -O3

	OPTION -m64
	OPTION -std=c++2a
	OPTION -fconcepts

	DEFINE -Dconcept="concept bool"
	DEFINE -D "WISH_REQUIRES\\(...\\)=\"requires __VA_ARGS__\""
	IDE_DEFINE WISH_REQUIRES(...)

	DEFINE -DWISH_GIT_BRANCH="${WISH_GIT_BRANCH}"
	DEFINE -DWISH_GIT_COMMIT_HASH="${WISH_GIT_COMMIT_HASH}"
	DEFINE -DWISH_SHORT_PATH_CUTOFF=${WISH_SHORT_PATH_CUTOFF}
	DEFINE -DWISH_SHORT_PATH_PREFIX="${CMAKE_SOURCE_DIR}/"
)

wish_create_library(
	PARENT libv
	TARGET vm4imp
	LINK PUBLIC libv::log libv::vm4 ext::assimp
)

// -------------------------------------------------------------------------------------------------

Additional lua.wish ideas:


debug = mode("debug")
release = mode("release")
dev = mode("dev")

config.target = "{PARENT_TARGET}_{TARGET}"
config.folder = "{PARENT_FOLDER}/{TARGET}"
config.alias  = "{PARENT_ALIAS}::{TARGET}"
config.source = "src/{FOLDER}/**.cpp"
config.header = "src/{FOLDER}/**.hpp"

config.result_path_binary_app      = "bin/{FOLDER}/"
config.result_path_binary_example  = "bin/{FOLDER}/"
config.result_path_binary_sandbox  = "bin/{FOLDER}/"
config.result_path_binary_test     = "bin/{FOLDER}/"
config.result_path_header          = "include/{FOLDER}/"
config.result_path_library_dynamic = "lib/{FOLDER}/"
config.result_path_library_static  = "lib/{FOLDER}/"

set.CMAKE_THREAD_PREFER_PTHREAD = "TRUE"
set.THREADS_PREFER_PTHREAD_FLAG = "TRUE"

find.package_require("Threads")
find.package_require("OpenGL")


ext_assimp = create_external("assimp", "https://github.com/assimp/assimp.git", "v5.0.0", {
	BUILD_SHARED_LIBS = OFF,
	CMAKE_EXPORT_COMPILE_COMMANDS = ON,
	ASSIMP_BUILD_ASSIMP_TOOLS = OFF,
	ASSIMP_BUILD_TESTS = OFF,
	ASSIMP_BUILD_ZLIB = ON,
	ASSIMP_NO_EXPORT = ON,

	ASSIMP_BUILD_ALL_IMPORTERS_BY_DEFAULT = OFF,
	ASSIMP_BUILD_FBX_IMPORTER = ON,
})
ext_assimp.link_public("assimp", "IrrXML", "zlibstatic")


libv = create_base("libv")

libv.warning("GNU VERSION_GREATER 7.0", "-Wduplicated-branches")
libv.warning("GNU VERSION_GREATER 7.0", "-Wrestrict")
libv.warning("GNU VERSION_GREATER 7.0", "-Wshadow-compatible-local")
libv.warning("GNU VERSION_GREATER 8.0", "-Wcast-align=strict")
libv.warning("GNU VERSION_GREATER 8.0", "-Wmultistatement-macros")

libv.option(debug, "-Og")
libv.option(debug, "--ggdb3")
libv.option(release, "-O3")
libv.option(release, "-static")
libv.option(dev, "-O3")
libv.option("-m64")
libv.option("-std=c++2a")
libv.option("-fconcepts")

libv.define("concept=\"concept bool\"")
libv.define("\"WISH_REQUIRES\\\\(...\\\\)=\\\"requires __VA_ARGS__\\\"\"")
libv.ide_define("WISH_REQUIRES(...)")

libv.define_wish_git_branch()
libv.define_wish_git_commit()
libv.define_wish_short_path_cutoff()
libv.define_wish_short_path_prefix()

libv_vm4imp = create_library(libv, "vm4imp");
libv_vm4imp.link_public(libv_log libv_vm4 ext_assimp);


// -------------------------------------------------------------------------------------------------

Additional lua.wish ideas 2:


debug = mode("debug")
release = mode("release")
dev = mode("dev")

set.CMAKE_THREAD_PREFER_PTHREAD = "TRUE"
set.THREADS_PREFER_PTHREAD_FLAG = "TRUE"
find.package_require("Threads")
find.package_require("OpenGL")


ext_assimp = create_external("assimp", "https://github.com/assimp/assimp.git", "v5.0.0", {
	BUILD_SHARED_LIBS = OFF,
	CMAKE_EXPORT_COMPILE_COMMANDS = ON,
	ASSIMP_BUILD_ASSIMP_TOOLS = OFF,
	ASSIMP_BUILD_TESTS = OFF,
	ASSIMP_BUILD_ZLIB = ON,
	ASSIMP_NO_EXPORT = ON,

	ASSIMP_BUILD_ALL_IMPORTERS_BY_DEFAULT = OFF,
	ASSIMP_BUILD_FBX_IMPORTER = ON,
})
ext_assimp.link_public("assimp", "IrrXML", "zlibstatic")


libv = create_base("libv")
libv.warning_all()

libv.option(debug, "-Og")
libv.option(debug, "--ggdb3")
libv.option(release, "-O3")
libv.option(release, "-static")
libv.option(dev, "-O3")
libv.option("-m64")
libv.option("-std=c++2a")
libv.option("-fconcepts")

libv.define("concept=\"concept bool\"")
libv.define("\"WISH_REQUIRES\\\\(...\\\\)=\\\"requires __VA_ARGS__\\\"\"")
libv.ide_define("WISH_REQUIRES(...)")

libv.define_wish_git_branch()
libv.define_wish_git_commit()
libv.define_wish_short_path_cutoff()
libv.define_wish_short_path_prefix()

libv_vm4imp = create_library(libv, "vm4imp");
libv_vm4imp.link_public(libv_log libv_vm4 ext_assimp);

// -------------------------------------------------------------------------------------------------

local nato_phonetic_alphabet = {
	"Alfa",
	"Bravo",
	"Charlie",
	"Delta",
	"Echo",
	"Foxtrot",
	"Golf",
	"Hotel",
	"India",
	"Juliet",
	"Kilo",
	"Lima",
	"Mike",
	"November",
	"Oscar",
	"Papa",
	"Quebec",
	"Romeo",
	"Sierra",
	"Tango",
	"Uniform",
	"Victor",
	"Whisky",
	"X-ray",
	"Yankee",
	"Zulu",
}

local greek_alphabet = {
	"Alpha",
	"Beta",
	"Gamma",
	"Delta",
	"Epsilon",
	"Zeta",
	"Eta",
	"Theta",
	"Iota",
	"Kappa",
	"Lambda",
	"Mu",
	"Nu",
	"Xi",
	"Omicron",
	"Pi",
	"Rho",
	"Sigma",
	"Tau",
	"Upsilon",
	"Phi",
	"Chi",
	"Psi",
	"Omega",
}
