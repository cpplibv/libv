// Project: libv, File: app/space/game_instance.hpp, Author: Cs치sz치r M치ty치s [Vader]

// hpp
#include <space/game_instance.hpp>
// libv
#include <libv/ctrl/feature_register.hpp>
#include <libv/ui/event/event_overlay.hpp>
#include <libv/ui/event_hub.hpp>
#include <libv/ui/settings.hpp>
//#include <libv/ctrl/controls.hpp>
//#include <libv/ui/component/component.hpp>
// pro
#include <space/camera_behaviour.hpp>
#include <space/canvas_behaviour.hpp>
#include <space/game_session.hpp>
#include <space/log.hpp>
#include <space/message_control.hpp>


// Not for long ?
#include <random> // TODO P1: Random seed should be generated by the playout system


namespace app {

// -------------------------------------------------------------------------------------------------

inline void event_for_global_test_mode(const libv::Frame& frame, const libv::input::EventKey& e) {
	const auto old_global_test_mode = global_test_mode;

	if (e.keycode == libv::input::Keycode::C && e.action != libv::input::Action::release) {
		const int32_t mode_count = 4;
		if (frame.isKeyPressed(libv::input::Keycode::ShiftLeft) || frame.isKeyPressed(libv::input::Keycode::ShiftRight))
			global_test_mode = global_test_mode == 0 ? mode_count - 1 : global_test_mode - 1;
		else
			global_test_mode = (global_test_mode + 1) % mode_count;
	}
	if (e.keycode == libv::input::Keycode::Backtick)
		global_test_mode = 0;
	if (e.keycode == libv::input::Keycode::Num1)
		global_test_mode = 1;
	if (e.keycode == libv::input::Keycode::Num2)
		global_test_mode = 2;
	if (e.keycode == libv::input::Keycode::Num3)
		global_test_mode = 3;

	log_space.info_if(old_global_test_mode != global_test_mode, "Test mode: {}", global_test_mode);
}

// -------------------------------------------------------------------------------------------------

GameInstance::GameInstance() :
	ui([] {
		libv::ui::Settings ui_settings;
		// TODO P1: Internalize used UI resources under space, currently: app/space/../../res/
		ui_settings.res_font.base_path = "../../res/font/";
		ui_settings.res_shader.base_path = "../../res/shader/";
		ui_settings.res_texture.base_path = "../../res/texture/";
		return ui_settings;
	}()) {

	register_nexus();

	controls.attach(frame);
	ui.attach(frame);

	frame.onKey.output([this](const libv::input::EventKey& e) {
		// TODO P1: Remove this, global test variables should be a generic concept
		event_for_global_test_mode(this->frame, e);
	});

	ui.event().global.connect_system<libv::ui::EventOverlay>([this](const libv::ui::EventOverlay& event) {
		log_space.info("Controls intercepted: {}", event.controls_intercepted());
		// TODO P1: A more seamless integration of UI and Controls would be nice
		controls.ignore_events(event.controls_intercepted());
	});
}

GameInstance::~GameInstance() {
	unregister_nexus();
}

void GameInstance::execute() {
	CameraBehaviour::register_controls(controls);
	CameraBehaviour::bind_default_controls(controls);
	CanvasBehaviour::register_controls(controls);
	CanvasBehaviour::bind_default_controls(controls);

//		enter_single_player();
	frame.show();
//		game_session->execute();
	frame.join();
}

void GameInstance::register_nexus() {
	nexus.connect<mc::RequestNameChange>(this, [this](const mc::RequestNameChange& event) {
		player.name = event.name;
		nexus.broadcast<mc::OnNameChange>();
	});

	nexus.connect<mc::RequestCreateClient>(this, [this](const mc::RequestCreateClient& event) {
		enter_multi_player_client(event.server_address, event.server_port);
		nexus.broadcast<mc::OnCreateClient>();
	});

	nexus.connect<mc::RequestCreateServer>(this, [this](const mc::RequestCreateServer& event) {
		enter_multi_player_server(event.server_port);
		nexus.broadcast<mc::OnCreateServer>();
	});

	nexus.connect<mc::RequestDestroyClient>(this, [this] {
		enter_single_player();
		nexus.broadcast<mc::OnDestroyClient>();
	});

	nexus.connect<mc::RequestDestroyServer>(this, [this] {
		enter_single_player();
		nexus.broadcast<mc::OnDestroyServer>();
	});


	// <<< These are game session requests
	nexus.connect<mc::RequestClearFleets>(this, [this] {
		game_session->playout->queue<app::CommandClearFleets>();
//			nexus.broadcast<mc::OnClearFleets>();
	});
	nexus.connect<mc::RequestShuffle>(this, [this] {
		game_session->playout->queue<app::CommandShuffle>(std::random_device{}());
		// <<< Do this in the playout buffer
		//			nexus.broadcast<mc::OnShuffle>();
	});
}

void GameInstance::unregister_nexus() {
	nexus.disconnect_all(this);
}

void GameInstance::enter_single_player() {
	game_session.reset();
	game_session = createSinglePlayer(*this, nexus, controls);
}

void GameInstance::enter_multi_player_client(std::string server_address, uint16_t server_port) {
	game_session.reset();
	game_session = createMultiPlayerClient(*this, nexus, controls, std::move(server_address), server_port);
}

void GameInstance::enter_multi_player_server(uint16_t port) {
	game_session.reset();
	game_session = createMultiPlayerServer(*this, nexus, controls, port);
}

// -------------------------------------------------------------------------------------------------

} // namespace app
