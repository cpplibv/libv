DONE: next step: mesh triangle strips, shader a depth miatt (flat)
submesh update
hotkey for switching between wire and fill
only build mesh when change
hook shader error overlay
DONE: bug image size (heightMap.storage meret allitas is kell)
seed csere, time-mal menni z koordinatan

template -> hpp, ne inline es kicsi simd vec4f x, vec4f y, int seed

60ms -> 16ms ( multithreading, better containers) <- after composition
multithreading:  ui must remain responsive (one dedicated thread)
	vector - > dynArray

03.09: Add gradient to heightmap
vegetation (popsickle)
biome heatmaps
More than one chunk


chuncked lod, tile (lod0, 1, 2), , (lod1-ben benne van lod0 stb)
ne lyukas: skirt
pop hatas elkerules: geomorphing (x, y, z1, z2)
texturazas

terep generalason hangsuly, nem a rendelesen
erozio algoritmusok (vizcseppes!) 10k-100k csepp
	megy a lokalis min fele, le csokk magassag, amugy no
deformalni a terepet (noise + gorbe) z ^ 3 pl vagy maszk (viz tavolsaga adott ponttol), fennsik

 perlin buckakat csinal, white noise felismerhetetlen
 nem lehet megmondani -> hasznaljuk a gyorsat

 to, folyo, nagy hegy <- felskiccelt - maszk -> generalas
 vizszint megadasa (0- vizszint + 5)
 folyo shader <- designer rakta le a folyot



1. world, camera, rendering
noise generator math/noise
	cellular
		worley, voronai
	fractal
		pingpong, ridged, FBM?
		octave:
			how many layer of noise
			1-15
			def: 10
		amplitude:
			how extreme should the elevation be?
			0.1-50
			def: 1
		frequency(float):
			how much detail per unit of space
			0.01 - 15
			default: 1.5f
		lacunarity(float):
			how quickly should freq. grow per octave
			1-10
			2.0 is common
		persistence/gain:
			How quickly should amplitude shrink per octave
			min: 0.1 - 1.0
			0.5 or 1/lacunarity
	perlin
	perlin_simplex
	value
	warp: regular - simplex for first
			domainwarp open simplex independent
		regular, polar, vortex, inverse
	palette
	animation

noise_simplex(x, y[, z, w]): float
noise_fractal_simplex(x, y[, z, w], octaves, amplitude, frequency, lacunarity, persistence):float
SurfaceGen
	seed
	1. height map, -> temp, humidity map, fertility
	If temperature increases it will lead to a decrease in relative humidity
	2. vegetation
	a humidity, temperature, height -> vegetation
	b biome range
	3.

	input:
		biome ranges/table (different from planet to planet)

	output:

SurfaceViewer
	frame/window
	ui
	canvas
		visualize surface
		camera
		controls


FastNoiseLite(int seed = 1337)
{
	mSeed = seed;
	mFrequency = 0.01f;
	mNoiseType = NoiseType_OpenSimplex2;
	mRotationType3D = RotationType3D_None;
	mTransformType3D = TransformType3D_DefaultOpenSimplex2;

	mFractalType = FractalType_None;
	mOctaves = 3;
	mLacunarity = 2.0f;
	mGain = 0.5f;
	mWeightedStrength = 0.0f;
	mPingPongStength = 2.0f;


	mCellularDistanceFunction = CellularDistanceFunction_EuclideanSq;
	mCellularReturnType = CellularReturnType_Distance;
	mCellularJitterModifier = 1.0f;

	mDomainWarpType = DomainWarpType_OpenSimplex2;
	mWarpTransformType3D = TransformType3D_DefaultOpenSimplex2;
	mFractalBounding = 1 / 1.75f;
	mDomainWarpAmp = 1.0f;
}



#pragma glslify: _warpRegular = require('./gl-noise/warpRegular.glsl', NOISE_FUN=fbmNoiseDual3D_warp, WarpParams=WarpParams)

struct FbmNoiseParams {
	int   octaves;           // number of octaves for fractal noise
	float octavesFract;      // fractional part of octaves value
	float frequency;         // noise frequency
	float gain;              // amplitude factor per octave
	float angle;             // rotation per octave
	float lacunarity;        // frequency factor per octave
	float turbulence;        // Z coordinate factor per octave
};

struct WarpParams {
	FbmNoiseParams basic;
	float anim;              // Z-position in 3D noise, for animation
	float amplitude;         // directional amplitude
	float rotation;          // rotational amplitude
};

vec2 warpRegular( vec2 pos, WarpParams warp ) {

	vec2 noise = NOISE_FUN( vec3( pos, warp.anim ), warp.basic );

	return pos + noise * warp.amplitude;
}

const noiseFunctions3D = {
	Perlin3D        : { shortKey: "p3", title: "Perlin" },
	SimplexPerlin3D : { shortKey: "s3", title: "Simplex" },
	Value3D         : { shortKey: "v3", title: "Value" },
	Cellular3D      : { shortKey: "c3", title: "Cellular" },
};

vec2 fbmNoiseDual3D( vec3 pos, FbmNoiseParams noise ) {

	vec2 result = vec2( 0 );

	float freq = noise.frequency;
	float z    = pos.z;
	float amp  = 1.0;

	// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0
	// due to the pseudo-random nature of the noise.
	// This value has been chosen by trial and error.
	const float zInc = 7.0;

	// Randomize noise for Y direction.
	const float yInc = 4.8;

	// Create fractal noise by adding multiple octaves of noise.
	for( int i = 0; i < noise.octaves; ++i ) {

		vec3 p = vec3( pos.xy * freq, z );
		float nx = NOISE_FUN( vec3( pos.xy * freq, z ) );
		float ny = NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );

		result += vec2( nx, ny ) * amp;

		freq   *= noise.lacunarity;
		amp    *= noise.gain;
		z      += zInc;
		z      *= noise.turbulence;
	}

	// Fractional part of octave value is used for smooth transition.
	vec3 p = vec3( pos.xy * freq, z );
	float nx = NOISE_FUN( vec3( pos.xy * freq, z ) );
	float ny = NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );

	result += vec2( nx, ny ) * amp * noise.octavesFract;

	return result;
}

#pragma glslify: export(fbmNoiseDual3D)


vec2 identity( vec2 value, WarpParams warp ) { return value; }
