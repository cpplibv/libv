
Star - System integration demo









--- STACK ------------------------------------------------------------------------------------------











UI Focus
	libv.ui: "Non-focusable" "kind of" components
			if it was used with mouse in a canvas it does not focus
			but if it was focused with focus traversal it does focus
			(or this is 2 orthogonal option)
			New concept: Focusability
				"Active focus on mouse interaction"
					\ onMouse: focuses the component, grabs input
					\ onKeyboard: normal focus
				"Passive focus on mouse interaction"
					\ onMouse: does not focuses the component and does not grabs input, but if there is a focus traversal from keyboard it will start from this component
					\ onKeyboard: normal focus
				"Focusable"
					\ onMouse/onKeyboard: normal focus

	libv.ui: If focused component receives a not interesting event
			but there is an active canvas who would react to it
			then auto change focus to the canvas.
			This is really tricky as controls and ui event systems conflict somewhat









UI Layout Invalidation
	libv.ui: If a child in panel_anchor or panel_full has not been invalidated,
			and the bounds of the panel did not change
			do not layout (calculate dynamic size) that component
			(only issue if the component does have dynamic size, in this case it must be called)

UI Event
	libv.ui: Style state active gets stuck when: toggle button pressed -> mouse moved out -> mouse released




Integration, controls, ui and controls interactions
	camera controls
	canvas controls
		currently [hold] might work with immediate change
		but what about [press]
	scene controls (simulation, space / pause)
		(timeControls)
		display pause/time control state on the ui
	3D picking ray







libv.re: improve glue layer, includes and ui integration

libv.ui: controls:
	scene controls: auto activates when the scene is part of the focus chain
	canvas controls: auto activates when the canvas is focused
	automated ways to register and bind defaults
		prepared function, and a template func or class wrapper

Organize surface scene is a mess

controls / camera
	Organize camera
		camera (merge all: star, space, vm4v, surface)
		how? camera_controls (merge all: star, space, vm4v, surface)

	base camera lib-wide
		camera_settings
		with extensibility per application

	register_controls(libv::ctrl::FeatureRegister controls)
		per controlled object (lib-wide)
		blacklist (wildcard) support
		whitelist (wildcard) support

	bind_default_controls(libv::ctrl::BindingRegister controls)
		per application




libv.re integration:
		wire in every settings





 > ui > Slider value change should not invalidate layout
			(make it a float region if it must)
			mouse context range remap might be needed!







Improve design
	Switch to nicer colors, bye bye blue background




libv.ui: Choose the null component constructor(s):
	ComponentT{}
	ComponentT{ptr} // where ptr == null
	ComponentT{nullptr}
	ComponentT{null_component}
	ComponentT::null()

app.star: whats next?
	have a surface
	pretty design, ui elements, edit stylesheet
	updater - self update
		on demand generation, keep last M
		release level to indicate auto generation of patch paths

app.star: Credits:
		performance: text/ui rendering
			in the credits scene text rendering is pretty slow, currently only 100 fps, if every license is written it will drop below 60 for sure, check out why
			maybe test with scissor
			| its the text rendering
				not the state switching
				not the render calls
			| It might be the data uploading

		> commenting mesh_stream.clear(); doubled the performance 100->200
		> not uploading new data at all 200->400
		? Would DSA help anything?
			| (yes), memory mapped buffer would help more

		mesh_stream.clear()
			off 200
			on 100
			we shouldnt need it

		glr.render(mesh_str...
				with mesh_stream.clear() off
			render calls off: 400
			render calls on: 250
			at this point, the only thing that is happening is:
				80 bindTexture and bindBufferRange

		glr.texture(t->textur
				with mesh_stream.clear() off
			off 250
			on 240

		glr.texture(t->textur
				with mesh_stream.clear() off
			off 270
			on 240

		!! CPU BOTTLENECK
			render + render exec take up 3.5ms (285 hard fps cap)

		|| Solutions:
			Primary: Dont call mesh_stream.clear()
			Primary: Do CPU culling
			mesh_stream
				Reduce renderer context mesh_data
					color rgba32f -> rgba8
					position vec3f -> vec2f
					? texture0_tile vec4f -> int
				Interleave attributes
				Upload data with Mapped memory
			render caching/invalidation is upon us?
			Advanced: glMultiDrawElementsIndirect
			everything is a font shader?
				\ and then a single glMultiDrawElementsIndirect draws everything? (needs ui atlas textures)

		read / understand:
			http://behindthepixels.io/assets/files/High-performance,%20Low-Overhead%20Rendering%20with%20OpenGL%20and%20Vulkan%20-%20Edward%20Liu.pdf
			You make it fast by not making any GL API calls, like bind buffer or draw, per object. Instead use multidraw*indirect, index ubo/ssbo with draw id for per object uniforms. Combine with persistently mapped buffers.

		libv.ui: Do more CPU culling, generalize, currently not everything is supported

		libv.ui: Component flag to report a component is well behaving in renders for early hierarchical culling
				(aka no render fragment exists the component layout_position and layout_size)

---


ToggleButton has the extra text_ variable from Button
!!! ToggleButton properties setters are not matching the LayoutTextLite pattern


libv.ui: Cleanup duty:
	LayoutTextLite Property
	LayoutTextLite might is kinda broken or all over the place (getPositions and the rest of the API)
	LayoutTextProperties

	// PropertyLP what does LP means again ???, do font font_size need it?

	get_nexus(0)
	Nicer function dispatch for non-component event hubs
		get_nexus(...)
		mark_as_signal(...)
		mark_as_slot(...)
		is_marked_as_signal(...)
		is_marked_as_slot(...)
	Concept usage, in a lightweight header libv/ui/component/detail/core_ptr.hpp
		template <typename T>
			requires (!std::derived_from<T, Component>)
		[[nodiscard]] constexpr inline auto get_core(const T& component_like) noexcept {
			return component_like.ptr();
		}

libv.ui: Setting: Do not clear buffer during render (Useful if there is a canvas that will do it anyways)




----------

place.it:
	idea: tracked entities as "sleeping ones", not 2 but 3 update state
		sleeping, awake, tracked
		runs different code

	Knowledge: Optimal vertex attribute layout: Position separate, everything else interleaved
	Knowledge: Optimal texture layout: IF there is alpha testing: Make opacity separate, if there is none RGBA is fine (everything else dont care, prefer merged)
	Knowledge: Anisotropic filtering is useless for many textures
	Knowledge: Mip maps are useless for some textures (UI textures dont care)

	glsl noise: simplest that i have seen https://www.shadertoy.com/view/DdBGDh


----------

app.star: cleanup
	config.cpp
		update became weird again

app.star: Settings
	grouping / separators / paging
	tooltips with description

libv.ui: PageLayouts

star: Separate "save/apply": preview and commit changes, or maybe the auto-save is fine as it is
	star: Make save/apply buttons inactive if there is no change

config: customization of behaviour:
	on_corrupt_file::exit
	on_corrupt_file::exit_and_alert
	on_corrupt_file::prompt_user // reset or exit
	on_corrupt_file::reset_to_default
	on_corrupt_file::reset_to_default_and_alert

	on_missing_file::create_default
	on_missing_file::create_default_and_alert
	on_missing_file::do_nothing
	on_missing_file::exit
	on_missing_file::exit_and_alert
	on_missing_file::prompt_user // in-memory default, create default or exit

	on_entry_change::auto_save(5s, 30s) // warmup, cooldown
	on_entry_change::do_nothing



libv.ui: Warn whenever a UI component out lives the UI object itself




=================================================================================================


app.star: Settings page back clear the focus while apply will rotate it to next

app.star: Self-Updater










--- Paper ------------------------------------------------------------------------------------------

Config:
	Configuration > Setting > Property

	Separate change and commit changes
		only store the new values during change
		during next frame loop apply change and broadcast events


--- Article collection -----------------------------------------------------------------------------

Infinite Grid: http://asliceofrendering.com/scene%20helper/2020/01/05/InfiniteGrid/
CMake source generation step: https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/
Deterministic Lockstep: https://gafferongames.com/post/deterministic_lockstep/

Improving vegetation vertex normals: https://www.artstation.com/artwork/w6nQ96

