// Project: libv, File: app/update/patch/resource/resource_common.lpp, Author: Cs치sz치r M치ty치s [Vader]

#pragma once

// libv
#include <libv/serialization/serialization.hpp>
#include <libv/serialization/types/std_string.hpp>
#include <libv/serialization/types/std_vector.hpp>
#include <libv/state/state.hpp>
// std
#include <string>
#include <vector>


namespace libv {
namespace update {

// -------------------------------------------------------------------------------------------------

//struct RequestResource {
//	std::string resource;
//	uint64_t offset;
//	uint64_t amount;
//
//	template <typename Archive> inline void serialize(Archive& ar) {
//		ar & LIBV_NVP(resource);
//		ar & LIBV_NVP(offset);
//		ar & LIBV_NVP(amount);
//	}
//};
//
//struct RequestCancel {
//	template <typename Archive> inline void serialize(Archive& ar) { }
//};
//
//struct ResponseBusy {
//	uint64_t busy_time;
//  //std::chrono::steady_clock::duration busy_time;
//
//	template <typename Archive> inline void serialize(Archive& ar) {
//		ar & LIBV_NVP(busy_time);
//	}
//};
//
//struct ResponseData {
//	uint64_t offset;
//	std::vector<std::byte> data;
//
//	template <typename Archive> inline void serialize(Archive& ar) {
//		ar & LIBV_NVP(offset);
//		ar & LIBV_NVP(data);
//	}
//};
//
//struct ResponseDone {
//	template <typename Archive> inline void serialize(Archive& ar) { }
//};

// -------------------------------------------------------------------------------------------------

struct ResourceMessages {
	struct RequestResourceSelect {
		std::string resource;

		template <typename Archive> inline void serialize(Archive& ar) {
			ar & LIBV_NVP(resource);
		}
	};

	struct RequestResourceDescription : RequestResourceSelect {
	};

	struct RequestCancel {
		template <typename Archive> inline void serialize(Archive& ar) {
			(void) ar;
		}
	};

	struct RequestEnd {
		template <typename Archive> inline void serialize(Archive& ar) {
			(void) ar;
		}
	};

	struct ResponseBusy {
		uint64_t busy_time;
//		std::chrono::steady_clock::duration busy_time;

		template <typename Archive> inline void serialize(Archive& ar) {
			ar & LIBV_NVP(busy_time);
		}
	};

	struct ResponseResourceNotFound {
		template <typename Archive> inline void serialize(Archive& ar) {
			(void) ar;
		}
	};

//	struct ResponseResourceInvalid {
//		template <typename Archive> inline void serialize(Archive& ar) {
//			(void) ar;
//		}
//	};

	struct ResponseResourceDescription {
		uint64_t size;

		template <typename Archive> inline void serialize(Archive& ar) {
			ar & LIBV_NVP(size);
		}
	};

	struct RequestResourceData {
		uint64_t offset;
		uint64_t amount;

		template <typename Archive> inline void serialize(Archive& ar) {
			ar & LIBV_NVP(offset);
			ar & LIBV_NVP(amount);
		}
	};

	struct ResponseResourceChunk {
		uint64_t offset;
		std::vector<std::byte> data;

		template <typename Archive> inline void serialize(Archive& ar) {
			ar & LIBV_NVP(offset);
			ar & LIBV_NVP(data);
		}
	};

	struct ResponseResourceEnd {
		template <typename Archive> inline void serialize(Archive& ar) {
			(void) ar;
		}
	};

public:
	template <typename Codec>
	static constexpr inline void message_types(Codec& codec) {
		codec.template type_client<10, RequestResourceSelect>();
		codec.template type_client<11, RequestResourceDescription>();
		codec.template type_client<12, RequestResourceData>();
		codec.template type_client<13, RequestCancel>();
		codec.template type_client<14, RequestEnd>();

		codec.template type_server<20, ResponseBusy>();
//		codec.template type_server<21, ResponseResourceInvalid>();
		codec.template type_server<22, ResponseResourceNotFound>();
		codec.template type_server<23, ResponseResourceDescription>();
		codec.template type_server<24, ResponseResourceChunk>();
		codec.template type_server<25, ResponseResourceEnd>();
	}
};

struct net_io_error {};

// -------------------------------------------------------------------------------------------------

using ev_RequestResourceSelect = libv::state::ev<const ResourceMessages::RequestResourceSelect&>;
using ev_RequestResourceDescription = libv::state::ev<const ResourceMessages::RequestResourceDescription&>;
using ev_RequestResourceData = libv::state::ev<const ResourceMessages::RequestResourceData&>;
using ev_RequestCancel = libv::state::ev<const ResourceMessages::RequestCancel&>;
using ev_RequestEnd = libv::state::ev<const ResourceMessages::RequestEnd&>;

using ev_ResponseBusy = libv::state::ev<const ResourceMessages::ResponseBusy&>;
//using ev_ResponseResourceInvalid = libv::state::ev<const ResourceMessages::ResponseResourceInvalid&>;
using ev_ResponseResourceNotFound = libv::state::ev<const ResourceMessages::ResponseResourceNotFound&>;
using ev_ResponseResourceDescription = libv::state::ev<const ResourceMessages::ResponseResourceDescription&>;
using ev_ResponseResourceChunk = libv::state::ev<const ResourceMessages::ResponseResourceChunk&>;
using ev_ResponseResourceEnd = libv::state::ev<const ResourceMessages::ResponseResourceEnd&>;

using ev_NetIOError = libv::state::ev<net_io_error>;

// -------------------------------------------------------------------------------------------------

} // namespace update
} // namespace libv
