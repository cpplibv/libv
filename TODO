

http://www.cmake.org/cmake/help/v3.3/command/configure_file.html

Új fajta signal: timerSignal
Mivel ez egy kicsit másabb, kell hozzá egy timer thread, meg az egész timer architektúra így nem a signal.hpp-ben kellene definiálni, hanem a timer.hpp-ban.
Valszeg ez egy egyszerü kompizitciója egy timer-nek és egy signalnak... Lehet, hogy nem is kell ehez külön signal tipus, csak a timernek kell tudni signalba adni... majd meglátjuk

https://github.com/sakra/cotire

P1 - std::future family

Priority levels for each operation

        Task        |   GL  |   IO  | Note
:------------------ | -----:| -----:|:--------------------------------------------------------------
 Default UIShader   |   100 |   100 | Unloading as a normal Shader
 Default Shader     |   200 |   200 |
 Default Font       |   300 |   300 |
 Default UITexture  |   400 |   400 | Unloading as a normal Texture
 Default Model      |   500 |   500 |
 Default Texture    |   600 |   600 |
 Render-Immediate   |  1100 |   -   | Starts by a timer when render time-window runs out
 Unload Texture     |  2100 |  2100 |
 Unload Model       |  2200 |  2200 |
 Unload Font        |  2400 |  2400 |
 Unload CSS         |   ?   |  2500 | Work in progress
 Unload UILayout    |   ?   |  2600 | Work in progress
 Unload Shader      |  2700 |  2700 |
 Load UIShader      |  3100 |  3100 | Unloading as a normal Shader
 Load Shader        |  3200 |  3200 |
 Load UILayout      |   ?   |  3300 | Work in progress
 Load CSS           |   ?   |  3400 | Work in progress
 Load Font          |  3500 |  3500 |
 Load UITexture     |  3600 |  3600 | Unloading as a normal Texture
 Load Model         |  3700 |  3700 |
 Load Texture       |  3800 |  3800 |
 Render-Residual    | 10000 |   -   | Always stays in queue as last operation

top layer std::function and forward!

Move frame from disconnected monitor

Tracing every event for right state enums / defines / handlers:
	Char
	CharMods
	CursorEnter
	CursorPos
	Drop
	FramebufferSize
	Key
	MouseButton
	Scroll
	WindowClose
	WindowFocus
	WindowIconify
	WindowPos
	WindowRefresh
	WindowSize
	Monitor


What is GLFW_USE_DWM_SWAP_INTERVAL?.... Test it off





variant
https://github.com/JasonL9000/cppcon14


two phase lookup, what, why, how?

-----
CMake resource folder
Move loadResource to Resource
Texture
Cube / Sky Textures http://sourceforge.net/projects/spacescape/
Skeleton animation

Render Target
Shadow Pass
Multi Pass

VM4 Animated mesh

http://www.oldunreal.com/editing/s3tc/ARB_texture_compression.pdf
http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html
OpenGL Reference page: https://www.opengl.org/sdk/docs/man/





----

Adopt TCLAP http://tclap.sourceforge.net is suitable

Contexted Resource
vl::log(__VL_ERROR__, __VL_POC__, __VL_GL__, "msg", args...)
struct vl::POC = position of code
Beside Component's shared_ptr provide a way of non owning ptr which is visible at call:
	container.add(testComponent, vl::non_owning); //simular as std::adopt_lock
Timed Event / Timer Support / Timer thread
Resettable and clearable timer / timer tasks
Implement Latch / Barrier based on open standard


Config Entry:
	- default
	- description
	- isset
	- name
	- type
	- value


Optimizing for prefetcher.
Optimizing for minimum number of opengl bind.
In ui static and dynamic render options for different components
Resource pack
The idea of dynamic renderer


----
Fresnel shader - Atmosphere
Cook-Torrance shader - Metal
Minnaert - More depth?
OrenNayar - More avg lambert







> RANDOM
template<class URNG>
int rnd(int n, URNG &engine) {
    using dist_t = std::uniform_int_distribution<>;
    using param_t = dist_t::param_type;

    static dist_t dist;
    param_t params{0,n-1};

    return dist(engine, params);
}




diffuse(1.0f, 1.0f, 1.0f, 1.0f),
specular(0.8f, 0.8f, 0.8f, 1.0f),
emission(0.0f, 0.0f, 0.0f, 1.0f),
ambient(0.1f, 0.1f, 0.1f, 1.0f),
reflective(1.0f, 1.0f, 1.0f, 1.0f),
shininess(32.0f) { }











GLuint fullScreenQuadVBO;

void cleanFullScreenQuad() {
	glDeleteBuffers(1, &fullScreenQuadVBO);
}

void initFullScreenQuad() {
	float vertexData[]{
		0.0f, 0.0f, -1.0f, -1.0f,
		1.0f, 0.0f, 1.0f, -1.0f,
		0.0f, 1.0f, -1.0f, 1.0f,
		1.0f, 1.0f, 1.0f, 1.0f
	};

	glGenBuffers(1, &fullScreenQuadVBO);
	glBindBuffer(GL_ARRAY_BUFFER, fullScreenQuadVBO);
	glBufferData(GL_ARRAY_BUFFER, (sizeof (float)) * 16, vertexData, GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void vglPassFullScreenQuad() {
	glBindBuffer(GL_ARRAY_BUFFER, fullScreenQuadVBO);
	glEnableVertexAttribArray(ATTRIBUTE_POSITION);
	glEnableVertexAttribArray(ATTRIBUTE_TEXCOORD0);

	glVertexAttribPointer(ATTRIBUTE_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof (float) * 4, ((void*) (sizeof (float) * 2)));
	glVertexAttribPointer(ATTRIBUTE_TEXCOORD0, 2, GL_FLOAT, GL_FALSE, sizeof (float) * 4, ((void*) (sizeof (float) * 0)));
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

	glDisableVertexAttribArray(ATTRIBUTE_TEXCOORD0);
	glDisableVertexAttribArray(ATTRIBUTE_POSITION);
	//	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void vglViewportFullScreen() {
	glViewport(0, 0, options.graphics.resolution.get().x
			, options.graphics.resolution.get().y);
}