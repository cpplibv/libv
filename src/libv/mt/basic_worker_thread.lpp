// Project: libv.mt, File: src/libv/mt/basic_worker_thread.hpp, Author: Cs치sz치r M치ty치s [Vader]

#pragma once

// libv
#include <libv/utility/unique_function.hpp>
#include <libv/log/log.hpp>
// std
#include <chrono>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <string>
#include <thread>


namespace libv {
namespace mt {

// -------------------------------------------------------------------------------------------------

template <typename Executor>
class basic_worker_thread {
	static constexpr std::chrono::steady_clock::time_point immediate = std::chrono::steady_clock::time_point::min();

	struct queued_task {
		std::chrono::steady_clock::time_point time;
		size_t index;
		libv::unique_function<void()> func;

		[[nodiscard]] friend constexpr inline bool operator<(const queued_task& lhs, const queued_task& rhs) noexcept {
			if (lhs.time == rhs.time)
				return lhs.index > rhs.index;
			return lhs.time > rhs.time;
		}
	};

private:
	std::priority_queue<queued_task> queue;
	mutable std::mutex queue_m;
	std::condition_variable work_cv;

	bool terminate = false;
	Executor executor;
	const std::string name_;

	size_t next_index = 0;

public:
	template <typename... Args>
	inline explicit basic_worker_thread(std::string name, Args&&... args);
	inline ~basic_worker_thread();

public:
	inline void execute_async(libv::unique_function<void()> func);
	inline void execute_async(libv::unique_function<void()> func, std::chrono::steady_clock::duration after);
	inline void execute_async(libv::unique_function<void()> func, std::chrono::steady_clock::time_point at);
	inline void stop();
	inline void join();

public:
	[[nodiscard]] inline const std::string& name() const noexcept {
		return name_;
	}
	[[nodiscard]] inline size_t task_queue_size() const noexcept {
		std::unique_lock lock(queue_m);
		return queue.size();
	}

public:
	void run();
};

// -------------------------------------------------------------------------------------------------

template <typename Executor>
template <typename... Args>
inline basic_worker_thread<Executor>::basic_worker_thread(std::string new_name, Args&&... args) :
	executor(std::forward<Args>(args)..., &basic_worker_thread::run, this),
	name_(std::move(new_name)) {}

template <typename Executor>
inline basic_worker_thread<Executor>::~basic_worker_thread() {
	// TODO P2: What should happen with tasks that are 'canceled', for now we just dont execute them, best would be an argument to the task like netts that tells it, that it is cancelled, with maybe a default way that it would just not get called
	stop();
}

// -------------------------------------------------------------------------------------------------

template <typename Executor>
inline void basic_worker_thread<Executor>::execute_async(libv::unique_function<void()> func) {
	execute_async(std::move(func), immediate);
}

template <typename Executor>
inline void basic_worker_thread<Executor>::execute_async(libv::unique_function<void()> func, std::chrono::steady_clock::duration after) {
	execute_async(std::move(func), std::chrono::steady_clock::now() + after);
}

template <typename Executor>
inline void basic_worker_thread<Executor>::execute_async(libv::unique_function<void()> func, std::chrono::steady_clock::time_point at) {
	std::unique_lock lock(queue_m);
	assert(!terminate && "Queueing task after worker thread has been stopped");

	queue.emplace(at, next_index++, std::move(func));
	work_cv.notify_one();
}

template <typename Executor>
inline void basic_worker_thread<Executor>::stop() {
	std::unique_lock lock(queue_m);
	terminate = true;
	work_cv.notify_all();
}

template <typename Executor>
inline void basic_worker_thread<Executor>::join() {
	executor.join();
}

// -------------------------------------------------------------------------------------------------

template <typename Executor>
inline void basic_worker_thread<Executor>::run() {
	libv::unique_function<void()> task;

	while (true) {
		{
			std::unique_lock lock(queue_m);

			// Wait for terminate, new task, or until the time of the top task is up
			while (true) {
				if (terminate) {
					break;

				} else if (queue.empty()) {
					work_cv.wait(lock);

				} else if (queue.top().time <= std::chrono::steady_clock::now()) {
					break;

				} else {
					const auto cvs = work_cv.wait_until(lock, queue.top().time);
					if (cvs == std::cv_status::timeout)
						break;
				}
			}

			if (terminate)
				break;

			task = std::move(const_cast<queued_task&>(queue.top()).func); // NOTE: const_cast is safe as the task is popped anyways but ugly
			queue.pop();
		}

		try {
			task();
		} catch (const std::exception& ex) {
			log.error("Exception occurred in {} basic_worker_thread: {}", name_, ex.what());
		}
	}

	// Process tasks that can be executed
	std::unique_lock queue_lock(queue_m);
	while (!queue.empty() && queue.top().time <= std::chrono::steady_clock::now()) {
		task = std::move(const_cast<queued_task&>(queue.top()).func); // NOTE: const_cast is safe but ugly as the task is popped anyways
		queue.pop();

		queue_lock.unlock();

		try {
			task();
		} catch (const std::exception& ex) {
			log.error("Exception occurred in {} basic_worker_thread: {}", name_, ex.what());
		}

		queue_lock.lock();
	}

	// NOTE: Currently the rest of the outlining task are just dropped, but they could be cancelled

	//	// Process tasks that has to be cancelled
	//	while (!queue.empty()) {
	//		task = std::move(const_cast<queued_task&>(queue.top()).func); // NOTE: const_cast is safe but ugly as the task is popped anyways
	//		queue.pop();
	//
	//		lock.unlock();
	//
	//		try {
	//			task(cancelled);
	//		} catch (const std::exception& ex) {
	//			log.error("Exception occurred in {} basic_worker_thread: {}", name_, ex.what());
	//		}
	//
	//		lock.lock();
	//	}
}

// -------------------------------------------------------------------------------------------------

} // namespace mt
} // namespace libv
